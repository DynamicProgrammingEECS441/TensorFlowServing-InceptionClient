// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/example/feature.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "tensorflow/core/example/Feature.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - FeatureRoot

@implementation FeatureRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - FeatureRoot_FileDescriptor

static GPBFileDescriptor *FeatureRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"tensorflow"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - BytesList

@implementation BytesList

@dynamic valueArray, valueArray_Count;

typedef struct BytesList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *valueArray;
} BytesList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "valueArray",
        .dataTypeSpecific.className = NULL,
        .number = BytesList_FieldNumber_ValueArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BytesList__storage_, valueArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BytesList class]
                                     rootClass:[FeatureRoot class]
                                          file:FeatureRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BytesList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FloatList

@implementation FloatList

@dynamic valueArray, valueArray_Count;

typedef struct FloatList__storage_ {
  uint32_t _has_storage_[1];
  GPBFloatArray *valueArray;
} FloatList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "valueArray",
        .dataTypeSpecific.className = NULL,
        .number = FloatList_FieldNumber_ValueArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FloatList__storage_, valueArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FloatList class]
                                     rootClass:[FeatureRoot class]
                                          file:FeatureRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FloatList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Int64List

@implementation Int64List

@dynamic valueArray, valueArray_Count;

typedef struct Int64List__storage_ {
  uint32_t _has_storage_[1];
  GPBInt64Array *valueArray;
} Int64List__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "valueArray",
        .dataTypeSpecific.className = NULL,
        .number = Int64List_FieldNumber_ValueArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Int64List__storage_, valueArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Int64List class]
                                     rootClass:[FeatureRoot class]
                                          file:FeatureRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Int64List__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Feature

@implementation Feature

@dynamic kindOneOfCase;
@dynamic bytesList;
@dynamic floatList;
@dynamic int64List;

typedef struct Feature__storage_ {
  uint32_t _has_storage_[2];
  BytesList *bytesList;
  FloatList *floatList;
  Int64List *int64List;
} Feature__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bytesList",
        .dataTypeSpecific.className = GPBStringifySymbol(BytesList),
        .number = Feature_FieldNumber_BytesList,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Feature__storage_, bytesList),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "floatList",
        .dataTypeSpecific.className = GPBStringifySymbol(FloatList),
        .number = Feature_FieldNumber_FloatList,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Feature__storage_, floatList),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "int64List",
        .dataTypeSpecific.className = GPBStringifySymbol(Int64List),
        .number = Feature_FieldNumber_Int64List,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Feature__storage_, int64List),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Feature class]
                                     rootClass:[FeatureRoot class]
                                          file:FeatureRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Feature__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "kind",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Feature_ClearKindOneOfCase(Feature *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - Features

@implementation Features

@dynamic feature, feature_Count;

typedef struct Features__storage_ {
  uint32_t _has_storage_[1];
  NSMutableDictionary *feature;
} Features__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "feature",
        .dataTypeSpecific.className = GPBStringifySymbol(Feature),
        .number = Features_FieldNumber_Feature,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Features__storage_, feature),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Features class]
                                     rootClass:[FeatureRoot class]
                                          file:FeatureRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Features__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FeatureList

@implementation FeatureList

@dynamic featureArray, featureArray_Count;

typedef struct FeatureList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *featureArray;
} FeatureList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "featureArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Feature),
        .number = FeatureList_FieldNumber_FeatureArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FeatureList__storage_, featureArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FeatureList class]
                                     rootClass:[FeatureRoot class]
                                          file:FeatureRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FeatureList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FeatureLists

@implementation FeatureLists

@dynamic featureList, featureList_Count;

typedef struct FeatureLists__storage_ {
  uint32_t _has_storage_[1];
  NSMutableDictionary *featureList;
} FeatureLists__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "featureList",
        .dataTypeSpecific.className = GPBStringifySymbol(FeatureList),
        .number = FeatureLists_FieldNumber_FeatureList,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FeatureLists__storage_, featureList),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FeatureLists class]
                                     rootClass:[FeatureRoot class]
                                          file:FeatureRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FeatureLists__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
