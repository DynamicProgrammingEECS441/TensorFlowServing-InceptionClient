// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/framework/tensor_slice.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers.h>
#else
 #import "GPBProtocolBuffers.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30002
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30002 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

CF_EXTERN_C_BEGIN

@class TensorSliceProto_Extent;

NS_ASSUME_NONNULL_BEGIN

#pragma mark - TensorSliceRoot

/**
 * Exposes the extension registry for this file.
 *
 * The base class provides:
 * @code
 *   + (GPBExtensionRegistry *)extensionRegistry;
 * @endcode
 * which is a @c GPBExtensionRegistry that includes all the extensions defined by
 * this file and all files that it depends on.
 **/
@interface TensorSliceRoot : GPBRootObject
@end

#pragma mark - TensorSliceProto

typedef GPB_ENUM(TensorSliceProto_FieldNumber) {
  TensorSliceProto_FieldNumber_ExtentArray = 1,
};

/**
 * Can only be interpreted if you know the corresponding TensorShape.
 **/
@interface TensorSliceProto : GPBMessage

/**
 * Extent of the slice in all tensor dimensions.
 *
 * Must have one entry for each of the dimension of the tensor that this
 * slice belongs to.  The order of sizes is the same as the order of
 * dimensions in the TensorShape.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<TensorSliceProto_Extent*> *extentArray;
/** The number of items in @c extentArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger extentArray_Count;

@end

#pragma mark - TensorSliceProto_Extent

typedef GPB_ENUM(TensorSliceProto_Extent_FieldNumber) {
  TensorSliceProto_Extent_FieldNumber_Start = 1,
  TensorSliceProto_Extent_FieldNumber_Length = 2,
};

typedef GPB_ENUM(TensorSliceProto_Extent_HasLength_OneOfCase) {
  TensorSliceProto_Extent_HasLength_OneOfCase_GPBUnsetOneOfCase = 0,
  TensorSliceProto_Extent_HasLength_OneOfCase_Length = 2,
};

/**
 * Extent of the slice in one dimension.
 **/
@interface TensorSliceProto_Extent : GPBMessage

/** Start index of the slice, starting at 0. */
@property(nonatomic, readwrite) int64_t start;

/**
 * Length of the slice: if the length is missing or -1 we will
 * interpret this as "everything in this dimension".  We use
 * "oneof" to preserve information about whether the length is
 * present without changing the serialization format from the
 * prior proto2 version of this proto.
 **/
@property(nonatomic, readonly) TensorSliceProto_Extent_HasLength_OneOfCase hasLengthOneOfCase;

@property(nonatomic, readwrite) int64_t length;

@end

/**
 * Clears whatever value was set for the oneof 'hasLength'.
 **/
void TensorSliceProto_Extent_ClearHasLengthOneOfCase(TensorSliceProto_Extent *message);

NS_ASSUME_NONNULL_END

CF_EXTERN_C_END

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
