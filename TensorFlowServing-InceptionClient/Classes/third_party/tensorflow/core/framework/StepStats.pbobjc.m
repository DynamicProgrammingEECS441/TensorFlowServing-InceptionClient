// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/framework/step_stats.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "tensorflow/core/framework/StepStats.pbobjc.h"
 #import "tensorflow/core/framework/AllocationDescription.pbobjc.h"
 #import "tensorflow/core/framework/TensorDescription.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - StepStatsRoot

@implementation StepStatsRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - StepStatsRoot_FileDescriptor

static GPBFileDescriptor *StepStatsRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"tensorflow"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - AllocatorMemoryUsed

@implementation AllocatorMemoryUsed

@dynamic allocatorName;
@dynamic totalBytes;
@dynamic peakBytes;
@dynamic liveBytes;

typedef struct AllocatorMemoryUsed__storage_ {
  uint32_t _has_storage_[1];
  NSString *allocatorName;
  int64_t totalBytes;
  int64_t peakBytes;
  int64_t liveBytes;
} AllocatorMemoryUsed__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "allocatorName",
        .dataTypeSpecific.className = NULL,
        .number = AllocatorMemoryUsed_FieldNumber_AllocatorName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AllocatorMemoryUsed__storage_, allocatorName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "totalBytes",
        .dataTypeSpecific.className = NULL,
        .number = AllocatorMemoryUsed_FieldNumber_TotalBytes,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AllocatorMemoryUsed__storage_, totalBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "peakBytes",
        .dataTypeSpecific.className = NULL,
        .number = AllocatorMemoryUsed_FieldNumber_PeakBytes,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AllocatorMemoryUsed__storage_, peakBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "liveBytes",
        .dataTypeSpecific.className = NULL,
        .number = AllocatorMemoryUsed_FieldNumber_LiveBytes,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AllocatorMemoryUsed__storage_, liveBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AllocatorMemoryUsed class]
                                     rootClass:[StepStatsRoot class]
                                          file:StepStatsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AllocatorMemoryUsed__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeOutput

@implementation NodeOutput

@dynamic slot;
@dynamic hasTensorDescription, tensorDescription;

typedef struct NodeOutput__storage_ {
  uint32_t _has_storage_[1];
  int32_t slot;
  TensorDescription *tensorDescription;
} NodeOutput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "slot",
        .dataTypeSpecific.className = NULL,
        .number = NodeOutput_FieldNumber_Slot,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeOutput__storage_, slot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tensorDescription",
        .dataTypeSpecific.className = GPBStringifySymbol(TensorDescription),
        .number = NodeOutput_FieldNumber_TensorDescription,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NodeOutput__storage_, tensorDescription),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeOutput class]
                                     rootClass:[StepStatsRoot class]
                                          file:StepStatsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeOutput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MemoryStats

@implementation MemoryStats

@dynamic hostTempMemorySize;
@dynamic deviceTempMemorySize;
@dynamic hostPersistentMemorySize;
@dynamic devicePersistentMemorySize;
@dynamic hostPersistentTensorAllocIdsArray, hostPersistentTensorAllocIdsArray_Count;
@dynamic devicePersistentTensorAllocIdsArray, devicePersistentTensorAllocIdsArray_Count;

typedef struct MemoryStats__storage_ {
  uint32_t _has_storage_[1];
  GPBInt64Array *hostPersistentTensorAllocIdsArray;
  GPBInt64Array *devicePersistentTensorAllocIdsArray;
  int64_t hostTempMemorySize;
  int64_t deviceTempMemorySize;
  int64_t hostPersistentMemorySize;
  int64_t devicePersistentMemorySize;
} MemoryStats__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hostTempMemorySize",
        .dataTypeSpecific.className = NULL,
        .number = MemoryStats_FieldNumber_HostTempMemorySize,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MemoryStats__storage_, hostTempMemorySize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "deviceTempMemorySize",
        .dataTypeSpecific.className = NULL,
        .number = MemoryStats_FieldNumber_DeviceTempMemorySize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MemoryStats__storage_, deviceTempMemorySize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hostPersistentMemorySize",
        .dataTypeSpecific.className = NULL,
        .number = MemoryStats_FieldNumber_HostPersistentMemorySize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MemoryStats__storage_, hostPersistentMemorySize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "devicePersistentMemorySize",
        .dataTypeSpecific.className = NULL,
        .number = MemoryStats_FieldNumber_DevicePersistentMemorySize,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MemoryStats__storage_, devicePersistentMemorySize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hostPersistentTensorAllocIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = MemoryStats_FieldNumber_HostPersistentTensorAllocIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MemoryStats__storage_, hostPersistentTensorAllocIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "devicePersistentTensorAllocIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = MemoryStats_FieldNumber_DevicePersistentTensorAllocIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MemoryStats__storage_, devicePersistentTensorAllocIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MemoryStats class]
                                     rootClass:[StepStatsRoot class]
                                          file:StepStatsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MemoryStats__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeExecStats

@implementation NodeExecStats

@dynamic nodeName;
@dynamic allStartMicros;
@dynamic opStartRelMicros;
@dynamic opEndRelMicros;
@dynamic allEndRelMicros;
@dynamic memoryArray, memoryArray_Count;
@dynamic outputArray, outputArray_Count;
@dynamic timelineLabel;
@dynamic scheduledMicros;
@dynamic threadId;
@dynamic referencedTensorArray, referencedTensorArray_Count;
@dynamic hasMemoryStats, memoryStats;

typedef struct NodeExecStats__storage_ {
  uint32_t _has_storage_[1];
  uint32_t threadId;
  NSString *nodeName;
  NSMutableArray *memoryArray;
  NSMutableArray *outputArray;
  NSString *timelineLabel;
  NSMutableArray *referencedTensorArray;
  MemoryStats *memoryStats;
  int64_t allStartMicros;
  int64_t opStartRelMicros;
  int64_t opEndRelMicros;
  int64_t allEndRelMicros;
  int64_t scheduledMicros;
} NodeExecStats__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodeName",
        .dataTypeSpecific.className = NULL,
        .number = NodeExecStats_FieldNumber_NodeName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeExecStats__storage_, nodeName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "allStartMicros",
        .dataTypeSpecific.className = NULL,
        .number = NodeExecStats_FieldNumber_AllStartMicros,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NodeExecStats__storage_, allStartMicros),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "opStartRelMicros",
        .dataTypeSpecific.className = NULL,
        .number = NodeExecStats_FieldNumber_OpStartRelMicros,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NodeExecStats__storage_, opStartRelMicros),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "opEndRelMicros",
        .dataTypeSpecific.className = NULL,
        .number = NodeExecStats_FieldNumber_OpEndRelMicros,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NodeExecStats__storage_, opEndRelMicros),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "allEndRelMicros",
        .dataTypeSpecific.className = NULL,
        .number = NodeExecStats_FieldNumber_AllEndRelMicros,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NodeExecStats__storage_, allEndRelMicros),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "memoryArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AllocatorMemoryUsed),
        .number = NodeExecStats_FieldNumber_MemoryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NodeExecStats__storage_, memoryArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outputArray",
        .dataTypeSpecific.className = GPBStringifySymbol(NodeOutput),
        .number = NodeExecStats_FieldNumber_OutputArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NodeExecStats__storage_, outputArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timelineLabel",
        .dataTypeSpecific.className = NULL,
        .number = NodeExecStats_FieldNumber_TimelineLabel,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NodeExecStats__storage_, timelineLabel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scheduledMicros",
        .dataTypeSpecific.className = NULL,
        .number = NodeExecStats_FieldNumber_ScheduledMicros,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(NodeExecStats__storage_, scheduledMicros),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "threadId",
        .dataTypeSpecific.className = NULL,
        .number = NodeExecStats_FieldNumber_ThreadId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(NodeExecStats__storage_, threadId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "referencedTensorArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AllocationDescription),
        .number = NodeExecStats_FieldNumber_ReferencedTensorArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NodeExecStats__storage_, referencedTensorArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "memoryStats",
        .dataTypeSpecific.className = GPBStringifySymbol(MemoryStats),
        .number = NodeExecStats_FieldNumber_MemoryStats,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(NodeExecStats__storage_, memoryStats),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeExecStats class]
                                     rootClass:[StepStatsRoot class]
                                          file:StepStatsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeExecStats__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeviceStepStats

@implementation DeviceStepStats

@dynamic device;
@dynamic nodeStatsArray, nodeStatsArray_Count;

typedef struct DeviceStepStats__storage_ {
  uint32_t _has_storage_[1];
  NSString *device;
  NSMutableArray *nodeStatsArray;
} DeviceStepStats__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "device",
        .dataTypeSpecific.className = NULL,
        .number = DeviceStepStats_FieldNumber_Device,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeviceStepStats__storage_, device),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nodeStatsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(NodeExecStats),
        .number = DeviceStepStats_FieldNumber_NodeStatsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DeviceStepStats__storage_, nodeStatsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeviceStepStats class]
                                     rootClass:[StepStatsRoot class]
                                          file:StepStatsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeviceStepStats__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StepStats

@implementation StepStats

@dynamic devStatsArray, devStatsArray_Count;

typedef struct StepStats__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *devStatsArray;
} StepStats__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "devStatsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(DeviceStepStats),
        .number = StepStats_FieldNumber_DevStatsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(StepStats__storage_, devStatsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StepStats class]
                                     rootClass:[StepStatsRoot class]
                                          file:StepStatsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StepStats__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
