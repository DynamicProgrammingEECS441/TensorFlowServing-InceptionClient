// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/framework/cost_graph.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "tensorflow/core/framework/CostGraph.pbobjc.h"
 #import "tensorflow/core/framework/TensorShape.pbobjc.h"
 #import "tensorflow/core/framework/Types.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - CostGraphRoot

@implementation CostGraphRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - CostGraphRoot_FileDescriptor

static GPBFileDescriptor *CostGraphRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"tensorflow"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - CostGraphDef

@implementation CostGraphDef

@dynamic nodeArray, nodeArray_Count;

typedef struct CostGraphDef__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *nodeArray;
} CostGraphDef__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodeArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CostGraphDef_Node),
        .number = CostGraphDef_FieldNumber_NodeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CostGraphDef__storage_, nodeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CostGraphDef class]
                                     rootClass:[CostGraphRoot class]
                                          file:CostGraphRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CostGraphDef__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CostGraphDef_Node

@implementation CostGraphDef_Node

@dynamic name;
@dynamic device;
@dynamic id_p;
@dynamic inputInfoArray, inputInfoArray_Count;
@dynamic outputInfoArray, outputInfoArray_Count;
@dynamic temporaryMemorySize;
@dynamic hostTempMemorySize;
@dynamic deviceTempMemorySize;
@dynamic hostPersistentMemorySize;
@dynamic devicePersistentMemorySize;
@dynamic computeCost;
@dynamic computeTime;
@dynamic memoryTime;
@dynamic isFinal;
@dynamic controlInputArray, controlInputArray_Count;

typedef struct CostGraphDef_Node__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  NSString *name;
  NSString *device;
  NSMutableArray *inputInfoArray;
  NSMutableArray *outputInfoArray;
  GPBInt32Array *controlInputArray;
  int64_t temporaryMemorySize;
  int64_t computeCost;
  int64_t hostTempMemorySize;
  int64_t deviceTempMemorySize;
  int64_t hostPersistentMemorySize;
  int64_t computeTime;
  int64_t memoryTime;
  int64_t devicePersistentMemorySize;
} CostGraphDef_Node__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = CostGraphDef_Node_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CostGraphDef_Node__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "device",
        .dataTypeSpecific.className = NULL,
        .number = CostGraphDef_Node_FieldNumber_Device,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CostGraphDef_Node__storage_, device),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = CostGraphDef_Node_FieldNumber_Id_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CostGraphDef_Node__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "inputInfoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CostGraphDef_Node_InputInfo),
        .number = CostGraphDef_Node_FieldNumber_InputInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CostGraphDef_Node__storage_, inputInfoArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outputInfoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CostGraphDef_Node_OutputInfo),
        .number = CostGraphDef_Node_FieldNumber_OutputInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CostGraphDef_Node__storage_, outputInfoArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "temporaryMemorySize",
        .dataTypeSpecific.className = NULL,
        .number = CostGraphDef_Node_FieldNumber_TemporaryMemorySize,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CostGraphDef_Node__storage_, temporaryMemorySize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isFinal",
        .dataTypeSpecific.className = NULL,
        .number = CostGraphDef_Node_FieldNumber_IsFinal,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "controlInputArray",
        .dataTypeSpecific.className = NULL,
        .number = CostGraphDef_Node_FieldNumber_ControlInputArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CostGraphDef_Node__storage_, controlInputArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "computeCost",
        .dataTypeSpecific.className = NULL,
        .number = CostGraphDef_Node_FieldNumber_ComputeCost,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(CostGraphDef_Node__storage_, computeCost),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hostTempMemorySize",
        .dataTypeSpecific.className = NULL,
        .number = CostGraphDef_Node_FieldNumber_HostTempMemorySize,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CostGraphDef_Node__storage_, hostTempMemorySize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "deviceTempMemorySize",
        .dataTypeSpecific.className = NULL,
        .number = CostGraphDef_Node_FieldNumber_DeviceTempMemorySize,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(CostGraphDef_Node__storage_, deviceTempMemorySize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hostPersistentMemorySize",
        .dataTypeSpecific.className = NULL,
        .number = CostGraphDef_Node_FieldNumber_HostPersistentMemorySize,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(CostGraphDef_Node__storage_, hostPersistentMemorySize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "computeTime",
        .dataTypeSpecific.className = NULL,
        .number = CostGraphDef_Node_FieldNumber_ComputeTime,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(CostGraphDef_Node__storage_, computeTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "memoryTime",
        .dataTypeSpecific.className = NULL,
        .number = CostGraphDef_Node_FieldNumber_MemoryTime,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(CostGraphDef_Node__storage_, memoryTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "devicePersistentMemorySize",
        .dataTypeSpecific.className = NULL,
        .number = CostGraphDef_Node_FieldNumber_DevicePersistentMemorySize,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(CostGraphDef_Node__storage_, devicePersistentMemorySize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CostGraphDef_Node class]
                                     rootClass:[CostGraphRoot class]
                                          file:CostGraphRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CostGraphDef_Node__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(CostGraphDef)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CostGraphDef_Node_InputInfo

@implementation CostGraphDef_Node_InputInfo

@dynamic precedingNode;
@dynamic precedingPort;

typedef struct CostGraphDef_Node_InputInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t precedingNode;
  int32_t precedingPort;
} CostGraphDef_Node_InputInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "precedingNode",
        .dataTypeSpecific.className = NULL,
        .number = CostGraphDef_Node_InputInfo_FieldNumber_PrecedingNode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CostGraphDef_Node_InputInfo__storage_, precedingNode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "precedingPort",
        .dataTypeSpecific.className = NULL,
        .number = CostGraphDef_Node_InputInfo_FieldNumber_PrecedingPort,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CostGraphDef_Node_InputInfo__storage_, precedingPort),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CostGraphDef_Node_InputInfo class]
                                     rootClass:[CostGraphRoot class]
                                          file:CostGraphRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CostGraphDef_Node_InputInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(CostGraphDef_Node)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CostGraphDef_Node_OutputInfo

@implementation CostGraphDef_Node_OutputInfo

@dynamic size;
@dynamic aliasInputPort;
@dynamic hasShape, shape;
@dynamic dtype;

typedef struct CostGraphDef_Node_OutputInfo__storage_ {
  uint32_t _has_storage_[1];
  DataType dtype;
  TensorShapeProto *shape;
  int64_t size;
  int64_t aliasInputPort;
} CostGraphDef_Node_OutputInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = CostGraphDef_Node_OutputInfo_FieldNumber_Size,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CostGraphDef_Node_OutputInfo__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "aliasInputPort",
        .dataTypeSpecific.className = NULL,
        .number = CostGraphDef_Node_OutputInfo_FieldNumber_AliasInputPort,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CostGraphDef_Node_OutputInfo__storage_, aliasInputPort),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "shape",
        .dataTypeSpecific.className = GPBStringifySymbol(TensorShapeProto),
        .number = CostGraphDef_Node_OutputInfo_FieldNumber_Shape,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CostGraphDef_Node_OutputInfo__storage_, shape),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dtype",
        .dataTypeSpecific.enumDescFunc = DataType_EnumDescriptor,
        .number = CostGraphDef_Node_OutputInfo_FieldNumber_Dtype,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CostGraphDef_Node_OutputInfo__storage_, dtype),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CostGraphDef_Node_OutputInfo class]
                                     rootClass:[CostGraphRoot class]
                                          file:CostGraphRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CostGraphDef_Node_OutputInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(CostGraphDef_Node)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CostGraphDef_Node_OutputInfo_Dtype_RawValue(CostGraphDef_Node_OutputInfo *message) {
  GPBDescriptor *descriptor = [CostGraphDef_Node_OutputInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CostGraphDef_Node_OutputInfo_FieldNumber_Dtype];
  return GPBGetMessageInt32Field(message, field);
}

void SetCostGraphDef_Node_OutputInfo_Dtype_RawValue(CostGraphDef_Node_OutputInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [CostGraphDef_Node_OutputInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CostGraphDef_Node_OutputInfo_FieldNumber_Dtype];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
