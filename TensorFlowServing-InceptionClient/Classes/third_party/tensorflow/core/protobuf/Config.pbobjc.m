// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/protobuf/config.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "tensorflow/core/protobuf/Config.pbobjc.h"
 #import "tensorflow/core/framework/CostGraph.pbobjc.h"
 #import "tensorflow/core/framework/Graph.pbobjc.h"
 #import "tensorflow/core/framework/StepStats.pbobjc.h"
 #import "tensorflow/core/protobuf/Debug.pbobjc.h"
 #import "tensorflow/core/protobuf/Cluster.pbobjc.h"
 #import "tensorflow/core/protobuf/RewriterConfig.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ConfigRoot

@implementation ConfigRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ConfigRoot_FileDescriptor

static GPBFileDescriptor *ConfigRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"tensorflow"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - GPUOptions

@implementation GPUOptions

@dynamic perProcessGpuMemoryFraction;
@dynamic allocatorType;
@dynamic deferredDeletionBytes;
@dynamic allowGrowth;
@dynamic visibleDeviceList;
@dynamic pollingActiveDelayUsecs;
@dynamic pollingInactiveDelayMsecs;
@dynamic forceGpuCompatible;

typedef struct GPUOptions__storage_ {
  uint32_t _has_storage_[1];
  int32_t pollingActiveDelayUsecs;
  int32_t pollingInactiveDelayMsecs;
  NSString *allocatorType;
  NSString *visibleDeviceList;
  double perProcessGpuMemoryFraction;
  int64_t deferredDeletionBytes;
} GPUOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "perProcessGpuMemoryFraction",
        .dataTypeSpecific.className = NULL,
        .number = GPUOptions_FieldNumber_PerProcessGpuMemoryFraction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GPUOptions__storage_, perProcessGpuMemoryFraction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "allocatorType",
        .dataTypeSpecific.className = NULL,
        .number = GPUOptions_FieldNumber_AllocatorType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GPUOptions__storage_, allocatorType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deferredDeletionBytes",
        .dataTypeSpecific.className = NULL,
        .number = GPUOptions_FieldNumber_DeferredDeletionBytes,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GPUOptions__storage_, deferredDeletionBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "allowGrowth",
        .dataTypeSpecific.className = NULL,
        .number = GPUOptions_FieldNumber_AllowGrowth,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "visibleDeviceList",
        .dataTypeSpecific.className = NULL,
        .number = GPUOptions_FieldNumber_VisibleDeviceList,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GPUOptions__storage_, visibleDeviceList),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pollingActiveDelayUsecs",
        .dataTypeSpecific.className = NULL,
        .number = GPUOptions_FieldNumber_PollingActiveDelayUsecs,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GPUOptions__storage_, pollingActiveDelayUsecs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pollingInactiveDelayMsecs",
        .dataTypeSpecific.className = NULL,
        .number = GPUOptions_FieldNumber_PollingInactiveDelayMsecs,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GPUOptions__storage_, pollingInactiveDelayMsecs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "forceGpuCompatible",
        .dataTypeSpecific.className = NULL,
        .number = GPUOptions_FieldNumber_ForceGpuCompatible,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPUOptions class]
                                     rootClass:[ConfigRoot class]
                                          file:ConfigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPUOptions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OptimizerOptions

@implementation OptimizerOptions

@dynamic doCommonSubexpressionElimination;
@dynamic doConstantFolding;
@dynamic doFunctionInlining;
@dynamic optLevel;
@dynamic globalJitLevel;

typedef struct OptimizerOptions__storage_ {
  uint32_t _has_storage_[1];
  OptimizerOptions_Level optLevel;
  OptimizerOptions_GlobalJitLevel globalJitLevel;
} OptimizerOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "doCommonSubexpressionElimination",
        .dataTypeSpecific.className = NULL,
        .number = OptimizerOptions_FieldNumber_DoCommonSubexpressionElimination,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "doConstantFolding",
        .dataTypeSpecific.className = NULL,
        .number = OptimizerOptions_FieldNumber_DoConstantFolding,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "optLevel",
        .dataTypeSpecific.enumDescFunc = OptimizerOptions_Level_EnumDescriptor,
        .number = OptimizerOptions_FieldNumber_OptLevel,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(OptimizerOptions__storage_, optLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "doFunctionInlining",
        .dataTypeSpecific.className = NULL,
        .number = OptimizerOptions_FieldNumber_DoFunctionInlining,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "globalJitLevel",
        .dataTypeSpecific.enumDescFunc = OptimizerOptions_GlobalJitLevel_EnumDescriptor,
        .number = OptimizerOptions_FieldNumber_GlobalJitLevel,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(OptimizerOptions__storage_, globalJitLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OptimizerOptions class]
                                     rootClass:[ConfigRoot class]
                                          file:ConfigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OptimizerOptions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t OptimizerOptions_OptLevel_RawValue(OptimizerOptions *message) {
  GPBDescriptor *descriptor = [OptimizerOptions descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OptimizerOptions_FieldNumber_OptLevel];
  return GPBGetMessageInt32Field(message, field);
}

void SetOptimizerOptions_OptLevel_RawValue(OptimizerOptions *message, int32_t value) {
  GPBDescriptor *descriptor = [OptimizerOptions descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OptimizerOptions_FieldNumber_OptLevel];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t OptimizerOptions_GlobalJitLevel_RawValue(OptimizerOptions *message) {
  GPBDescriptor *descriptor = [OptimizerOptions descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OptimizerOptions_FieldNumber_GlobalJitLevel];
  return GPBGetMessageInt32Field(message, field);
}

void SetOptimizerOptions_GlobalJitLevel_RawValue(OptimizerOptions *message, int32_t value) {
  GPBDescriptor *descriptor = [OptimizerOptions descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OptimizerOptions_FieldNumber_GlobalJitLevel];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum OptimizerOptions_Level

GPBEnumDescriptor *OptimizerOptions_Level_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "L1\000L0\000";
    static const int32_t values[] = {
        OptimizerOptions_Level_L1,
        OptimizerOptions_Level_L0,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OptimizerOptions_Level)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OptimizerOptions_Level_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OptimizerOptions_Level_IsValidValue(int32_t value__) {
  switch (value__) {
    case OptimizerOptions_Level_L1:
    case OptimizerOptions_Level_L0:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum OptimizerOptions_GlobalJitLevel

GPBEnumDescriptor *OptimizerOptions_GlobalJitLevel_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Default\000Off\000On1\000On2\000";
    static const int32_t values[] = {
        OptimizerOptions_GlobalJitLevel_Default,
        OptimizerOptions_GlobalJitLevel_Off,
        OptimizerOptions_GlobalJitLevel_On1,
        OptimizerOptions_GlobalJitLevel_On2,
    };
    static const char *extraTextFormatInfo = "\002\002b\201\000\003b\201\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OptimizerOptions_GlobalJitLevel)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OptimizerOptions_GlobalJitLevel_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OptimizerOptions_GlobalJitLevel_IsValidValue(int32_t value__) {
  switch (value__) {
    case OptimizerOptions_GlobalJitLevel_Default:
    case OptimizerOptions_GlobalJitLevel_Off:
    case OptimizerOptions_GlobalJitLevel_On1:
    case OptimizerOptions_GlobalJitLevel_On2:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GraphOptions

@implementation GraphOptions

@dynamic enableRecvScheduling;
@dynamic hasOptimizerOptions, optimizerOptions;
@dynamic buildCostModel;
@dynamic buildCostModelAfter;
@dynamic inferShapes;
@dynamic placePrunedGraph;
@dynamic enableBfloat16Sendrecv;
@dynamic timelineStep;
@dynamic hasRewriteOptions, rewriteOptions;

typedef struct GraphOptions__storage_ {
  uint32_t _has_storage_[1];
  int32_t timelineStep;
  OptimizerOptions *optimizerOptions;
  RewriterConfig *rewriteOptions;
  int64_t buildCostModel;
  int64_t buildCostModelAfter;
} GraphOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "enableRecvScheduling",
        .dataTypeSpecific.className = NULL,
        .number = GraphOptions_FieldNumber_EnableRecvScheduling,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "optimizerOptions",
        .dataTypeSpecific.className = GPBStringifySymbol(OptimizerOptions),
        .number = GraphOptions_FieldNumber_OptimizerOptions,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GraphOptions__storage_, optimizerOptions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "buildCostModel",
        .dataTypeSpecific.className = NULL,
        .number = GraphOptions_FieldNumber_BuildCostModel,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GraphOptions__storage_, buildCostModel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "inferShapes",
        .dataTypeSpecific.className = NULL,
        .number = GraphOptions_FieldNumber_InferShapes,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "placePrunedGraph",
        .dataTypeSpecific.className = NULL,
        .number = GraphOptions_FieldNumber_PlacePrunedGraph,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "enableBfloat16Sendrecv",
        .dataTypeSpecific.className = NULL,
        .number = GraphOptions_FieldNumber_EnableBfloat16Sendrecv,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "timelineStep",
        .dataTypeSpecific.className = NULL,
        .number = GraphOptions_FieldNumber_TimelineStep,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(GraphOptions__storage_, timelineStep),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "buildCostModelAfter",
        .dataTypeSpecific.className = NULL,
        .number = GraphOptions_FieldNumber_BuildCostModelAfter,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GraphOptions__storage_, buildCostModelAfter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "rewriteOptions",
        .dataTypeSpecific.className = GPBStringifySymbol(RewriterConfig),
        .number = GraphOptions_FieldNumber_RewriteOptions,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(GraphOptions__storage_, rewriteOptions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GraphOptions class]
                                     rootClass:[ConfigRoot class]
                                          file:ConfigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GraphOptions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ThreadPoolOptionProto

@implementation ThreadPoolOptionProto

@dynamic numThreads;

typedef struct ThreadPoolOptionProto__storage_ {
  uint32_t _has_storage_[1];
  int32_t numThreads;
} ThreadPoolOptionProto__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "numThreads",
        .dataTypeSpecific.className = NULL,
        .number = ThreadPoolOptionProto_FieldNumber_NumThreads,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ThreadPoolOptionProto__storage_, numThreads),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ThreadPoolOptionProto class]
                                     rootClass:[ConfigRoot class]
                                          file:ConfigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ThreadPoolOptionProto__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCOptions

@implementation RPCOptions

@dynamic useRpcForInprocessMaster;

typedef struct RPCOptions__storage_ {
  uint32_t _has_storage_[1];
} RPCOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "useRpcForInprocessMaster",
        .dataTypeSpecific.className = NULL,
        .number = RPCOptions_FieldNumber_UseRpcForInprocessMaster,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCOptions class]
                                     rootClass:[ConfigRoot class]
                                          file:ConfigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCOptions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConfigProto

@implementation ConfigProto

@dynamic deviceCount, deviceCount_Count;
@dynamic intraOpParallelismThreads;
@dynamic interOpParallelismThreads;
@dynamic usePerSessionThreads;
@dynamic sessionInterOpThreadPoolArray, sessionInterOpThreadPoolArray_Count;
@dynamic placementPeriod;
@dynamic deviceFiltersArray, deviceFiltersArray_Count;
@dynamic hasGpuOptions, gpuOptions;
@dynamic allowSoftPlacement;
@dynamic logDevicePlacement;
@dynamic hasGraphOptions, graphOptions;
@dynamic operationTimeoutInMs;
@dynamic hasRpcOptions, rpcOptions;
@dynamic hasClusterDef, clusterDef;

typedef struct ConfigProto__storage_ {
  uint32_t _has_storage_[1];
  int32_t intraOpParallelismThreads;
  int32_t placementPeriod;
  int32_t interOpParallelismThreads;
  GPBStringInt32Dictionary *deviceCount;
  NSMutableArray *deviceFiltersArray;
  GPUOptions *gpuOptions;
  GraphOptions *graphOptions;
  NSMutableArray *sessionInterOpThreadPoolArray;
  RPCOptions *rpcOptions;
  ClusterDef *clusterDef;
  int64_t operationTimeoutInMs;
} ConfigProto__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceCount",
        .dataTypeSpecific.className = NULL,
        .number = ConfigProto_FieldNumber_DeviceCount,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ConfigProto__storage_, deviceCount),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "intraOpParallelismThreads",
        .dataTypeSpecific.className = NULL,
        .number = ConfigProto_FieldNumber_IntraOpParallelismThreads,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConfigProto__storage_, intraOpParallelismThreads),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "placementPeriod",
        .dataTypeSpecific.className = NULL,
        .number = ConfigProto_FieldNumber_PlacementPeriod,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ConfigProto__storage_, placementPeriod),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "deviceFiltersArray",
        .dataTypeSpecific.className = NULL,
        .number = ConfigProto_FieldNumber_DeviceFiltersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ConfigProto__storage_, deviceFiltersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "interOpParallelismThreads",
        .dataTypeSpecific.className = NULL,
        .number = ConfigProto_FieldNumber_InterOpParallelismThreads,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ConfigProto__storage_, interOpParallelismThreads),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "gpuOptions",
        .dataTypeSpecific.className = GPBStringifySymbol(GPUOptions),
        .number = ConfigProto_FieldNumber_GpuOptions,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ConfigProto__storage_, gpuOptions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "allowSoftPlacement",
        .dataTypeSpecific.className = NULL,
        .number = ConfigProto_FieldNumber_AllowSoftPlacement,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "logDevicePlacement",
        .dataTypeSpecific.className = NULL,
        .number = ConfigProto_FieldNumber_LogDevicePlacement,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "usePerSessionThreads",
        .dataTypeSpecific.className = NULL,
        .number = ConfigProto_FieldNumber_UsePerSessionThreads,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "graphOptions",
        .dataTypeSpecific.className = GPBStringifySymbol(GraphOptions),
        .number = ConfigProto_FieldNumber_GraphOptions,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ConfigProto__storage_, graphOptions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "operationTimeoutInMs",
        .dataTypeSpecific.className = NULL,
        .number = ConfigProto_FieldNumber_OperationTimeoutInMs,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ConfigProto__storage_, operationTimeoutInMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sessionInterOpThreadPoolArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ThreadPoolOptionProto),
        .number = ConfigProto_FieldNumber_SessionInterOpThreadPoolArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ConfigProto__storage_, sessionInterOpThreadPoolArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rpcOptions",
        .dataTypeSpecific.className = GPBStringifySymbol(RPCOptions),
        .number = ConfigProto_FieldNumber_RpcOptions,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ConfigProto__storage_, rpcOptions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clusterDef",
        .dataTypeSpecific.className = GPBStringifySymbol(ClusterDef),
        .number = ConfigProto_FieldNumber_ClusterDef,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ConfigProto__storage_, clusterDef),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConfigProto class]
                                     rootClass:[ConfigRoot class]
                                          file:ConfigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConfigProto__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RunOptions

@implementation RunOptions

@dynamic traceLevel;
@dynamic timeoutInMs;
@dynamic interOpThreadPool;
@dynamic outputPartitionGraphs;
@dynamic hasDebugOptions, debugOptions;

typedef struct RunOptions__storage_ {
  uint32_t _has_storage_[1];
  RunOptions_TraceLevel traceLevel;
  int32_t interOpThreadPool;
  DebugOptions *debugOptions;
  int64_t timeoutInMs;
} RunOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "traceLevel",
        .dataTypeSpecific.enumDescFunc = RunOptions_TraceLevel_EnumDescriptor,
        .number = RunOptions_FieldNumber_TraceLevel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RunOptions__storage_, traceLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "timeoutInMs",
        .dataTypeSpecific.className = NULL,
        .number = RunOptions_FieldNumber_TimeoutInMs,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RunOptions__storage_, timeoutInMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "interOpThreadPool",
        .dataTypeSpecific.className = NULL,
        .number = RunOptions_FieldNumber_InterOpThreadPool,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RunOptions__storage_, interOpThreadPool),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "outputPartitionGraphs",
        .dataTypeSpecific.className = NULL,
        .number = RunOptions_FieldNumber_OutputPartitionGraphs,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "debugOptions",
        .dataTypeSpecific.className = GPBStringifySymbol(DebugOptions),
        .number = RunOptions_FieldNumber_DebugOptions,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RunOptions__storage_, debugOptions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RunOptions class]
                                     rootClass:[ConfigRoot class]
                                          file:ConfigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RunOptions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RunOptions_TraceLevel_RawValue(RunOptions *message) {
  GPBDescriptor *descriptor = [RunOptions descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RunOptions_FieldNumber_TraceLevel];
  return GPBGetMessageInt32Field(message, field);
}

void SetRunOptions_TraceLevel_RawValue(RunOptions *message, int32_t value) {
  GPBDescriptor *descriptor = [RunOptions descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RunOptions_FieldNumber_TraceLevel];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RunOptions_TraceLevel

GPBEnumDescriptor *RunOptions_TraceLevel_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "NoTrace\000SoftwareTrace\000HardwareTrace\000Full"
        "Trace\000";
    static const int32_t values[] = {
        RunOptions_TraceLevel_NoTrace,
        RunOptions_TraceLevel_SoftwareTrace,
        RunOptions_TraceLevel_HardwareTrace,
        RunOptions_TraceLevel_FullTrace,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RunOptions_TraceLevel)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RunOptions_TraceLevel_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RunOptions_TraceLevel_IsValidValue(int32_t value__) {
  switch (value__) {
    case RunOptions_TraceLevel_NoTrace:
    case RunOptions_TraceLevel_SoftwareTrace:
    case RunOptions_TraceLevel_HardwareTrace:
    case RunOptions_TraceLevel_FullTrace:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RunMetadata

@implementation RunMetadata

@dynamic hasStepStats, stepStats;
@dynamic hasCostGraph, costGraph;
@dynamic partitionGraphsArray, partitionGraphsArray_Count;

typedef struct RunMetadata__storage_ {
  uint32_t _has_storage_[1];
  StepStats *stepStats;
  CostGraphDef *costGraph;
  NSMutableArray *partitionGraphsArray;
} RunMetadata__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stepStats",
        .dataTypeSpecific.className = GPBStringifySymbol(StepStats),
        .number = RunMetadata_FieldNumber_StepStats,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RunMetadata__storage_, stepStats),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "costGraph",
        .dataTypeSpecific.className = GPBStringifySymbol(CostGraphDef),
        .number = RunMetadata_FieldNumber_CostGraph,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RunMetadata__storage_, costGraph),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "partitionGraphsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GraphDef),
        .number = RunMetadata_FieldNumber_PartitionGraphsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RunMetadata__storage_, partitionGraphsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RunMetadata class]
                                     rootClass:[ConfigRoot class]
                                          file:ConfigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RunMetadata__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
