// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/protobuf/meta_graph.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers.h>
#else
 #import "GPBProtocolBuffers.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30002
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30002 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

CF_EXTERN_C_BEGIN

@class AssetFileDef;
@class CollectionDef;
@class CollectionDef_AnyList;
@class CollectionDef_BytesList;
@class CollectionDef_FloatList;
@class CollectionDef_Int64List;
@class CollectionDef_NodeList;
@class GPBAny;
@class GraphDef;
@class MetaGraphDef_MetaInfoDef;
@class OpList;
@class SaverDef;
@class SignatureDef;
@class TensorInfo;
@class TensorShapeProto;
GPB_ENUM_FWD_DECLARE(DataType);

NS_ASSUME_NONNULL_BEGIN

#pragma mark - MetaGraphRoot

/**
 * Exposes the extension registry for this file.
 *
 * The base class provides:
 * @code
 *   + (GPBExtensionRegistry *)extensionRegistry;
 * @endcode
 * which is a @c GPBExtensionRegistry that includes all the extensions defined by
 * this file and all files that it depends on.
 **/
@interface MetaGraphRoot : GPBRootObject
@end

#pragma mark - MetaGraphDef

typedef GPB_ENUM(MetaGraphDef_FieldNumber) {
  MetaGraphDef_FieldNumber_MetaInfoDef = 1,
  MetaGraphDef_FieldNumber_GraphDef = 2,
  MetaGraphDef_FieldNumber_SaverDef = 3,
  MetaGraphDef_FieldNumber_CollectionDef = 4,
  MetaGraphDef_FieldNumber_SignatureDef = 5,
  MetaGraphDef_FieldNumber_AssetFileDefArray = 6,
};

/**
 * NOTE: This protocol buffer is evolving, and will go through revisions in the
 * coming months.
 *
 * Protocol buffer containing the following which are necessary to restart
 * training, run inference. It can be used to serialize/de-serialize memory
 * objects necessary for running computation in a graph when crossing the
 * process boundary. It can be used for long term storage of graphs,
 * cross-language execution of graphs, etc.
 *   MetaInfoDef
 *   GraphDef
 *   SaverDef
 *   CollectionDef
 *   TensorInfo
 *   SignatureDef
 **/
@interface MetaGraphDef : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) MetaGraphDef_MetaInfoDef *metaInfoDef;
/** Test to see if @c metaInfoDef has been set. */
@property(nonatomic, readwrite) BOOL hasMetaInfoDef;

/** GraphDef. */
@property(nonatomic, readwrite, strong, null_resettable) GraphDef *graphDef;
/** Test to see if @c graphDef has been set. */
@property(nonatomic, readwrite) BOOL hasGraphDef;

/** SaverDef. */
@property(nonatomic, readwrite, strong, null_resettable) SaverDef *saverDef;
/** Test to see if @c saverDef has been set. */
@property(nonatomic, readwrite) BOOL hasSaverDef;

/**
 * collection_def: Map from collection name to collections.
 * See CollectionDef section for details.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableDictionary<NSString*, CollectionDef*> *collectionDef;
/** The number of items in @c collectionDef without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger collectionDef_Count;

/**
 * signature_def: Map from user supplied key for a signature to a single
 * SignatureDef.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableDictionary<NSString*, SignatureDef*> *signatureDef;
/** The number of items in @c signatureDef without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger signatureDef_Count;

/** Asset file def to be used with the defined graph. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<AssetFileDef*> *assetFileDefArray;
/** The number of items in @c assetFileDefArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger assetFileDefArray_Count;

@end

#pragma mark - MetaGraphDef_MetaInfoDef

typedef GPB_ENUM(MetaGraphDef_MetaInfoDef_FieldNumber) {
  MetaGraphDef_MetaInfoDef_FieldNumber_MetaGraphVersion = 1,
  MetaGraphDef_MetaInfoDef_FieldNumber_StrippedOpList = 2,
  MetaGraphDef_MetaInfoDef_FieldNumber_AnyInfo = 3,
  MetaGraphDef_MetaInfoDef_FieldNumber_TagsArray = 4,
  MetaGraphDef_MetaInfoDef_FieldNumber_TensorflowVersion = 5,
  MetaGraphDef_MetaInfoDef_FieldNumber_TensorflowGitVersion = 6,
};

/**
 * Meta information regarding the graph to be exported.  To be used by users
 * of this protocol buffer to encode information regarding their meta graph.
 **/
@interface MetaGraphDef_MetaInfoDef : GPBMessage

/**
 * User specified Version string. Can be the name of the model and revision,
 * steps this model has been trained to, etc.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *metaGraphVersion;

/**
 * A copy of the OpDefs used by the producer of this graph_def.
 * Descriptions and Ops not used in graph_def are stripped out.
 **/
@property(nonatomic, readwrite, strong, null_resettable) OpList *strippedOpList;
/** Test to see if @c strippedOpList has been set. */
@property(nonatomic, readwrite) BOOL hasStrippedOpList;

/**
 * A serialized protobuf. Can be the time this meta graph is created, or
 * modified, or name of the model.
 **/
@property(nonatomic, readwrite, strong, null_resettable) GPBAny *anyInfo;
/** Test to see if @c anyInfo has been set. */
@property(nonatomic, readwrite) BOOL hasAnyInfo;

/**
 * User supplied tag(s) on the meta_graph and included graph_def.
 *
 * MetaGraphDefs should be tagged with their capabilities or use-cases.
 * Examples: "train", "serve", "gpu", "tpu", etc.
 * These tags enable loaders to access the MetaGraph(s) appropriate for a
 * specific use-case or runtime environment.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NSString*> *tagsArray;
/** The number of items in @c tagsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger tagsArray_Count;

/**
 * The __version__ string of the tensorflow build used to write this graph.
 * This will be populated by the framework, which will overwrite any user
 * supplied value.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *tensorflowVersion;

/**
 * The __git_version__ string of the tensorflow build used to write this
 * graph. This will be populated by the framework, which will overwrite any
 * user supplied value.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *tensorflowGitVersion;

@end

#pragma mark - CollectionDef

typedef GPB_ENUM(CollectionDef_FieldNumber) {
  CollectionDef_FieldNumber_NodeList = 1,
  CollectionDef_FieldNumber_BytesList = 2,
  CollectionDef_FieldNumber_Int64List = 3,
  CollectionDef_FieldNumber_FloatList = 4,
  CollectionDef_FieldNumber_AnyList = 5,
};

typedef GPB_ENUM(CollectionDef_Kind_OneOfCase) {
  CollectionDef_Kind_OneOfCase_GPBUnsetOneOfCase = 0,
  CollectionDef_Kind_OneOfCase_NodeList = 1,
  CollectionDef_Kind_OneOfCase_BytesList = 2,
  CollectionDef_Kind_OneOfCase_Int64List = 3,
  CollectionDef_Kind_OneOfCase_FloatList = 4,
  CollectionDef_Kind_OneOfCase_AnyList = 5,
};

/**
 * CollectionDef should cover most collections.
 * To add a user-defined collection, do one of the following:
 * 1. For simple data types, such as string, int, float:
 *      tf.add_to_collection("your_collection_name", your_simple_value)
 *    strings will be stored as bytes_list.
 *
 * 2. For Protobuf types, there are three ways to add them:
 *    1) tf.add_to_collection("your_collection_name",
 *         your_proto.SerializeToString())
 *
 *       collection_def {
 *         key: "user_defined_bytes_collection"
 *         value {
 *           bytes_list {
 *             value: "queue_name: \\"test_queue\\"\\n"
 *           }
 *         }
 *       }
 *
 *  or
 *
 *    2) tf.add_to_collection("your_collection_name", str(your_proto))
 *
 *       collection_def {
 *         key: "user_defined_string_collection"
 *         value {
 *          bytes_list {
 *             value: "\\n\\ntest_queue"
 *           }
 *         }
 *       }
 *
 *  or
 *
 *    3) any_buf = any_pb2.Any()
 *       tf.add_to_collection("your_collection_name",
 *         any_buf.Pack(your_proto))
 *
 *       collection_def {
 *         key: "user_defined_any_collection"
 *         value {
 *           any_list {
 *             value {
 *               type_url: "type.googleapis.com/tensorflow.QueueRunnerDef"
 *               value: "\\n\\ntest_queue"
 *             }
 *           }
 *         }
 *       }
 *
 * 3. For Python objects, implement to_proto() and from_proto(), and register
 *    them in the following manner:
 *    ops.register_proto_function("your_collection_name",
 *                                proto_type,
 *                                to_proto=YourPythonObject.to_proto,
 *                                from_proto=YourPythonObject.from_proto)
 *    These functions will be invoked to serialize and de-serialize the
 *    collection. For example,
 *    ops.register_proto_function(ops.GraphKeys.GLOBAL_VARIABLES,
 *                                proto_type=variable_pb2.VariableDef,
 *                                to_proto=Variable.to_proto,
 *                                from_proto=Variable.from_proto)
 **/
@interface CollectionDef : GPBMessage

@property(nonatomic, readonly) CollectionDef_Kind_OneOfCase kindOneOfCase;

@property(nonatomic, readwrite, strong, null_resettable) CollectionDef_NodeList *nodeList;

@property(nonatomic, readwrite, strong, null_resettable) CollectionDef_BytesList *bytesList;

@property(nonatomic, readwrite, strong, null_resettable) CollectionDef_Int64List *int64List;

@property(nonatomic, readwrite, strong, null_resettable) CollectionDef_FloatList *floatList;

@property(nonatomic, readwrite, strong, null_resettable) CollectionDef_AnyList *anyList;

@end

/**
 * Clears whatever value was set for the oneof 'kind'.
 **/
void CollectionDef_ClearKindOneOfCase(CollectionDef *message);

#pragma mark - CollectionDef_NodeList

typedef GPB_ENUM(CollectionDef_NodeList_FieldNumber) {
  CollectionDef_NodeList_FieldNumber_ValueArray = 1,
};

/**
 * NodeList is used for collecting nodes in graph. For example
 * collection_def {
 *   key: "summaries"
 *   value {
 *     node_list {
 *       value: "input_producer/ScalarSummary:0"
 *       value: "shuffle_batch/ScalarSummary:0"
 *       value: "ImageSummary:0"
 *     }
 *   }
 **/
@interface CollectionDef_NodeList : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NSString*> *valueArray;
/** The number of items in @c valueArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger valueArray_Count;

@end

#pragma mark - CollectionDef_BytesList

typedef GPB_ENUM(CollectionDef_BytesList_FieldNumber) {
  CollectionDef_BytesList_FieldNumber_ValueArray = 1,
};

/**
 * BytesList is used for collecting strings and serialized protobufs. For
 * example:
 * collection_def {
 *   key: "trainable_variables"
 *   value {
 *     bytes_list {
 *       value: "\\n\\017conv1/weights:0\\022\\024conv1/weights/Assign
 *              \\032\\024conv1/weights/read:0"
 *       value: "\\n\\016conv1/biases:0\\022\\023conv1/biases/Assign\\032
 *              \\023conv1/biases/read:0"
 *     }
 *   }
 * }
 **/
@interface CollectionDef_BytesList : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NSData*> *valueArray;
/** The number of items in @c valueArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger valueArray_Count;

@end

#pragma mark - CollectionDef_Int64List

typedef GPB_ENUM(CollectionDef_Int64List_FieldNumber) {
  CollectionDef_Int64List_FieldNumber_ValueArray = 1,
};

/**
 * Int64List is used for collecting int, int64 and long values.
 **/
@interface CollectionDef_Int64List : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) GPBInt64Array *valueArray;
/** The number of items in @c valueArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger valueArray_Count;

@end

#pragma mark - CollectionDef_FloatList

typedef GPB_ENUM(CollectionDef_FloatList_FieldNumber) {
  CollectionDef_FloatList_FieldNumber_ValueArray = 1,
};

/**
 * FloatList is used for collecting float values.
 **/
@interface CollectionDef_FloatList : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) GPBFloatArray *valueArray;
/** The number of items in @c valueArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger valueArray_Count;

@end

#pragma mark - CollectionDef_AnyList

typedef GPB_ENUM(CollectionDef_AnyList_FieldNumber) {
  CollectionDef_AnyList_FieldNumber_ValueArray = 1,
};

/**
 * AnyList is used for collecting Any protos.
 **/
@interface CollectionDef_AnyList : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<GPBAny*> *valueArray;
/** The number of items in @c valueArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger valueArray_Count;

@end

#pragma mark - TensorInfo

typedef GPB_ENUM(TensorInfo_FieldNumber) {
  TensorInfo_FieldNumber_Name = 1,
  TensorInfo_FieldNumber_Dtype = 2,
  TensorInfo_FieldNumber_TensorShape = 3,
};

/**
 * Information about a Tensor necessary for feeding or retrieval.
 **/
@interface TensorInfo : GPBMessage

@property(nonatomic, readwrite, copy, null_resettable) NSString *name;

@property(nonatomic, readwrite) enum DataType dtype;

@property(nonatomic, readwrite, strong, null_resettable) TensorShapeProto *tensorShape;
/** Test to see if @c tensorShape has been set. */
@property(nonatomic, readwrite) BOOL hasTensorShape;

@end

/**
 * Fetches the raw value of a @c TensorInfo's @c dtype property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t TensorInfo_Dtype_RawValue(TensorInfo *message);
/**
 * Sets the raw value of an @c TensorInfo's @c dtype property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetTensorInfo_Dtype_RawValue(TensorInfo *message, int32_t value);

#pragma mark - SignatureDef

typedef GPB_ENUM(SignatureDef_FieldNumber) {
  SignatureDef_FieldNumber_Inputs = 1,
  SignatureDef_FieldNumber_Outputs = 2,
  SignatureDef_FieldNumber_MethodName = 3,
};

/**
 * SignatureDef defines the signature of a computation supported by a TensorFlow
 * graph.
 *
 * For example, a model with two loss computations, sharing a single input,
 * might have the following signature_def map.
 *
 * Note that across the two SignatureDefs "loss_A" and "loss_B", the input key,
 * output key, and method_name are identical, and will be used by system(s) that
 * implement or rely upon this particular loss method. The output tensor names
 * differ, demonstrating how different outputs can exist for the same method.
 *
 * signature_def {
 *   key: "loss_A"
 *   value {
 *     inputs {
 *       key: "input"
 *       value {
 *         name: "input:0"
 *         dtype: DT_STRING
 *         tensor_shape: ...
 *       }
 *     }
 *     outputs {
 *       key: "loss_output"
 *       value {
 *         name: "loss_output_A:0"
 *         dtype: DT_FLOAT
 *         tensor_shape: ...
 *       }
 *     }
 *   }
 *   ...
 *   method_name: "some/package/compute_loss"
 * }
 * signature_def {
 *   key: "loss_B"
 *   value {
 *     inputs {
 *       key: "input"
 *       value {
 *         name: "input:0"
 *         dtype: DT_STRING
 *         tensor_shape: ...
 *       }
 *     }
 *     outputs {
 *       key: "loss_output"
 *       value {
 *         name: "loss_output_B:0"
 *         dtype: DT_FLOAT
 *         tensor_shape: ...
 *       }
 *     }
 *   }
 *   ...
 *   method_name: "some/package/compute_loss"
 * }
 **/
@interface SignatureDef : GPBMessage

/** Named input parameters. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableDictionary<NSString*, TensorInfo*> *inputs;
/** The number of items in @c inputs without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger inputs_Count;

/** Named output parameters. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableDictionary<NSString*, TensorInfo*> *outputs;
/** The number of items in @c outputs without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger outputs_Count;

/**
 * Extensible method_name information enabling third-party users to mark a
 * SignatureDef as supporting a particular method. This enables producers and
 * consumers of SignatureDefs, e.g. a model definition library and a serving
 * library to have a clear hand-off regarding the semantics of a computation.
 *
 * Note that multiple SignatureDefs in a single MetaGraphDef may have the same
 * method_name. This is commonly used to support multi-headed computation,
 * where a single graph computation may return multiple results.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *methodName;

@end

#pragma mark - AssetFileDef

typedef GPB_ENUM(AssetFileDef_FieldNumber) {
  AssetFileDef_FieldNumber_TensorInfo = 1,
  AssetFileDef_FieldNumber_Filename = 2,
};

/**
 * An asset file def for a single file or a set of sharded files with the same
 * name.
 **/
@interface AssetFileDef : GPBMessage

/** The tensor to bind the asset filename to. */
@property(nonatomic, readwrite, strong, null_resettable) TensorInfo *tensorInfo;
/** Test to see if @c tensorInfo has been set. */
@property(nonatomic, readwrite) BOOL hasTensorInfo;

/**
 * The filename within an assets directory. Note: does not include the path
 * prefix, i.e. directories. For an asset at /tmp/path/vocab.txt, the filename
 * would be "vocab.txt".
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *filename;

@end

NS_ASSUME_NONNULL_END

CF_EXTERN_C_END

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
