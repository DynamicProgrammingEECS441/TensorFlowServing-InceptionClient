// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/protobuf/meta_graph.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/Any.pbobjc.h>
#else
 #import "google/protobuf/Any.pbobjc.h"
#endif

 #import "tensorflow/core/protobuf/MetaGraph.pbobjc.h"
 #import "tensorflow/core/framework/Graph.pbobjc.h"
 #import "tensorflow/core/framework/OpDef.pbobjc.h"
 #import "tensorflow/core/framework/TensorShape.pbobjc.h"
 #import "tensorflow/core/framework/Types.pbobjc.h"
 #import "tensorflow/core/protobuf/Saver.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - MetaGraphRoot

@implementation MetaGraphRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - MetaGraphRoot_FileDescriptor

static GPBFileDescriptor *MetaGraphRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"tensorflow"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - MetaGraphDef

@implementation MetaGraphDef

@dynamic hasMetaInfoDef, metaInfoDef;
@dynamic hasGraphDef, graphDef;
@dynamic hasSaverDef, saverDef;
@dynamic collectionDef, collectionDef_Count;
@dynamic signatureDef, signatureDef_Count;
@dynamic assetFileDefArray, assetFileDefArray_Count;

typedef struct MetaGraphDef__storage_ {
  uint32_t _has_storage_[1];
  MetaGraphDef_MetaInfoDef *metaInfoDef;
  GraphDef *graphDef;
  SaverDef *saverDef;
  NSMutableDictionary *collectionDef;
  NSMutableDictionary *signatureDef;
  NSMutableArray *assetFileDefArray;
} MetaGraphDef__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "metaInfoDef",
        .dataTypeSpecific.className = GPBStringifySymbol(MetaGraphDef_MetaInfoDef),
        .number = MetaGraphDef_FieldNumber_MetaInfoDef,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MetaGraphDef__storage_, metaInfoDef),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "graphDef",
        .dataTypeSpecific.className = GPBStringifySymbol(GraphDef),
        .number = MetaGraphDef_FieldNumber_GraphDef,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MetaGraphDef__storage_, graphDef),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "saverDef",
        .dataTypeSpecific.className = GPBStringifySymbol(SaverDef),
        .number = MetaGraphDef_FieldNumber_SaverDef,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MetaGraphDef__storage_, saverDef),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "collectionDef",
        .dataTypeSpecific.className = GPBStringifySymbol(CollectionDef),
        .number = MetaGraphDef_FieldNumber_CollectionDef,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MetaGraphDef__storage_, collectionDef),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signatureDef",
        .dataTypeSpecific.className = GPBStringifySymbol(SignatureDef),
        .number = MetaGraphDef_FieldNumber_SignatureDef,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MetaGraphDef__storage_, signatureDef),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "assetFileDefArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AssetFileDef),
        .number = MetaGraphDef_FieldNumber_AssetFileDefArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MetaGraphDef__storage_, assetFileDefArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MetaGraphDef class]
                                     rootClass:[MetaGraphRoot class]
                                          file:MetaGraphRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MetaGraphDef__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MetaGraphDef_MetaInfoDef

@implementation MetaGraphDef_MetaInfoDef

@dynamic metaGraphVersion;
@dynamic hasStrippedOpList, strippedOpList;
@dynamic hasAnyInfo, anyInfo;
@dynamic tagsArray, tagsArray_Count;
@dynamic tensorflowVersion;
@dynamic tensorflowGitVersion;

typedef struct MetaGraphDef_MetaInfoDef__storage_ {
  uint32_t _has_storage_[1];
  NSString *metaGraphVersion;
  OpList *strippedOpList;
  GPBAny *anyInfo;
  NSMutableArray *tagsArray;
  NSString *tensorflowVersion;
  NSString *tensorflowGitVersion;
} MetaGraphDef_MetaInfoDef__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "metaGraphVersion",
        .dataTypeSpecific.className = NULL,
        .number = MetaGraphDef_MetaInfoDef_FieldNumber_MetaGraphVersion,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MetaGraphDef_MetaInfoDef__storage_, metaGraphVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "strippedOpList",
        .dataTypeSpecific.className = GPBStringifySymbol(OpList),
        .number = MetaGraphDef_MetaInfoDef_FieldNumber_StrippedOpList,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MetaGraphDef_MetaInfoDef__storage_, strippedOpList),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "anyInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = MetaGraphDef_MetaInfoDef_FieldNumber_AnyInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MetaGraphDef_MetaInfoDef__storage_, anyInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tagsArray",
        .dataTypeSpecific.className = NULL,
        .number = MetaGraphDef_MetaInfoDef_FieldNumber_TagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MetaGraphDef_MetaInfoDef__storage_, tagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tensorflowVersion",
        .dataTypeSpecific.className = NULL,
        .number = MetaGraphDef_MetaInfoDef_FieldNumber_TensorflowVersion,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MetaGraphDef_MetaInfoDef__storage_, tensorflowVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tensorflowGitVersion",
        .dataTypeSpecific.className = NULL,
        .number = MetaGraphDef_MetaInfoDef_FieldNumber_TensorflowGitVersion,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MetaGraphDef_MetaInfoDef__storage_, tensorflowGitVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MetaGraphDef_MetaInfoDef class]
                                     rootClass:[MetaGraphRoot class]
                                          file:MetaGraphRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MetaGraphDef_MetaInfoDef__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(MetaGraphDef)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CollectionDef

@implementation CollectionDef

@dynamic kindOneOfCase;
@dynamic nodeList;
@dynamic bytesList;
@dynamic int64List;
@dynamic floatList;
@dynamic anyList;

typedef struct CollectionDef__storage_ {
  uint32_t _has_storage_[2];
  CollectionDef_NodeList *nodeList;
  CollectionDef_BytesList *bytesList;
  CollectionDef_Int64List *int64List;
  CollectionDef_FloatList *floatList;
  CollectionDef_AnyList *anyList;
} CollectionDef__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodeList",
        .dataTypeSpecific.className = GPBStringifySymbol(CollectionDef_NodeList),
        .number = CollectionDef_FieldNumber_NodeList,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(CollectionDef__storage_, nodeList),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bytesList",
        .dataTypeSpecific.className = GPBStringifySymbol(CollectionDef_BytesList),
        .number = CollectionDef_FieldNumber_BytesList,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(CollectionDef__storage_, bytesList),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "int64List",
        .dataTypeSpecific.className = GPBStringifySymbol(CollectionDef_Int64List),
        .number = CollectionDef_FieldNumber_Int64List,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(CollectionDef__storage_, int64List),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "floatList",
        .dataTypeSpecific.className = GPBStringifySymbol(CollectionDef_FloatList),
        .number = CollectionDef_FieldNumber_FloatList,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(CollectionDef__storage_, floatList),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "anyList",
        .dataTypeSpecific.className = GPBStringifySymbol(CollectionDef_AnyList),
        .number = CollectionDef_FieldNumber_AnyList,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(CollectionDef__storage_, anyList),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CollectionDef class]
                                     rootClass:[MetaGraphRoot class]
                                          file:MetaGraphRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CollectionDef__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "kind",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void CollectionDef_ClearKindOneOfCase(CollectionDef *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - CollectionDef_NodeList

@implementation CollectionDef_NodeList

@dynamic valueArray, valueArray_Count;

typedef struct CollectionDef_NodeList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *valueArray;
} CollectionDef_NodeList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "valueArray",
        .dataTypeSpecific.className = NULL,
        .number = CollectionDef_NodeList_FieldNumber_ValueArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CollectionDef_NodeList__storage_, valueArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CollectionDef_NodeList class]
                                     rootClass:[MetaGraphRoot class]
                                          file:MetaGraphRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CollectionDef_NodeList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(CollectionDef)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CollectionDef_BytesList

@implementation CollectionDef_BytesList

@dynamic valueArray, valueArray_Count;

typedef struct CollectionDef_BytesList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *valueArray;
} CollectionDef_BytesList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "valueArray",
        .dataTypeSpecific.className = NULL,
        .number = CollectionDef_BytesList_FieldNumber_ValueArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CollectionDef_BytesList__storage_, valueArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CollectionDef_BytesList class]
                                     rootClass:[MetaGraphRoot class]
                                          file:MetaGraphRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CollectionDef_BytesList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(CollectionDef)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CollectionDef_Int64List

@implementation CollectionDef_Int64List

@dynamic valueArray, valueArray_Count;

typedef struct CollectionDef_Int64List__storage_ {
  uint32_t _has_storage_[1];
  GPBInt64Array *valueArray;
} CollectionDef_Int64List__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "valueArray",
        .dataTypeSpecific.className = NULL,
        .number = CollectionDef_Int64List_FieldNumber_ValueArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CollectionDef_Int64List__storage_, valueArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CollectionDef_Int64List class]
                                     rootClass:[MetaGraphRoot class]
                                          file:MetaGraphRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CollectionDef_Int64List__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(CollectionDef)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CollectionDef_FloatList

@implementation CollectionDef_FloatList

@dynamic valueArray, valueArray_Count;

typedef struct CollectionDef_FloatList__storage_ {
  uint32_t _has_storage_[1];
  GPBFloatArray *valueArray;
} CollectionDef_FloatList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "valueArray",
        .dataTypeSpecific.className = NULL,
        .number = CollectionDef_FloatList_FieldNumber_ValueArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CollectionDef_FloatList__storage_, valueArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CollectionDef_FloatList class]
                                     rootClass:[MetaGraphRoot class]
                                          file:MetaGraphRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CollectionDef_FloatList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(CollectionDef)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CollectionDef_AnyList

@implementation CollectionDef_AnyList

@dynamic valueArray, valueArray_Count;

typedef struct CollectionDef_AnyList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *valueArray;
} CollectionDef_AnyList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "valueArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = CollectionDef_AnyList_FieldNumber_ValueArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CollectionDef_AnyList__storage_, valueArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CollectionDef_AnyList class]
                                     rootClass:[MetaGraphRoot class]
                                          file:MetaGraphRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CollectionDef_AnyList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(CollectionDef)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TensorInfo

@implementation TensorInfo

@dynamic name;
@dynamic dtype;
@dynamic hasTensorShape, tensorShape;

typedef struct TensorInfo__storage_ {
  uint32_t _has_storage_[1];
  DataType dtype;
  NSString *name;
  TensorShapeProto *tensorShape;
} TensorInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = TensorInfo_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TensorInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dtype",
        .dataTypeSpecific.enumDescFunc = DataType_EnumDescriptor,
        .number = TensorInfo_FieldNumber_Dtype,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TensorInfo__storage_, dtype),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "tensorShape",
        .dataTypeSpecific.className = GPBStringifySymbol(TensorShapeProto),
        .number = TensorInfo_FieldNumber_TensorShape,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TensorInfo__storage_, tensorShape),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TensorInfo class]
                                     rootClass:[MetaGraphRoot class]
                                          file:MetaGraphRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TensorInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TensorInfo_Dtype_RawValue(TensorInfo *message) {
  GPBDescriptor *descriptor = [TensorInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TensorInfo_FieldNumber_Dtype];
  return GPBGetMessageInt32Field(message, field);
}

void SetTensorInfo_Dtype_RawValue(TensorInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [TensorInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TensorInfo_FieldNumber_Dtype];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - SignatureDef

@implementation SignatureDef

@dynamic inputs, inputs_Count;
@dynamic outputs, outputs_Count;
@dynamic methodName;

typedef struct SignatureDef__storage_ {
  uint32_t _has_storage_[1];
  NSMutableDictionary *inputs;
  NSMutableDictionary *outputs;
  NSString *methodName;
} SignatureDef__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inputs",
        .dataTypeSpecific.className = GPBStringifySymbol(TensorInfo),
        .number = SignatureDef_FieldNumber_Inputs,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SignatureDef__storage_, inputs),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outputs",
        .dataTypeSpecific.className = GPBStringifySymbol(TensorInfo),
        .number = SignatureDef_FieldNumber_Outputs,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SignatureDef__storage_, outputs),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "methodName",
        .dataTypeSpecific.className = NULL,
        .number = SignatureDef_FieldNumber_MethodName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignatureDef__storage_, methodName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignatureDef class]
                                     rootClass:[MetaGraphRoot class]
                                          file:MetaGraphRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignatureDef__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AssetFileDef

@implementation AssetFileDef

@dynamic hasTensorInfo, tensorInfo;
@dynamic filename;

typedef struct AssetFileDef__storage_ {
  uint32_t _has_storage_[1];
  TensorInfo *tensorInfo;
  NSString *filename;
} AssetFileDef__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tensorInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(TensorInfo),
        .number = AssetFileDef_FieldNumber_TensorInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AssetFileDef__storage_, tensorInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "filename",
        .dataTypeSpecific.className = NULL,
        .number = AssetFileDef_FieldNumber_Filename,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AssetFileDef__storage_, filename),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AssetFileDef class]
                                     rootClass:[MetaGraphRoot class]
                                          file:MetaGraphRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AssetFileDef__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
