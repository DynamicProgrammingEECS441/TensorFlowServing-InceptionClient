// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/util/test_log.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/Any.pbobjc.h>
#else
 #import "google/protobuf/Any.pbobjc.h"
#endif

 #import "tensorflow/core/util/TestLog.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - TestLogRoot

@implementation TestLogRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - TestLogRoot_FileDescriptor

static GPBFileDescriptor *TestLogRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"tensorflow"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - EntryValue

@implementation EntryValue

@dynamic kindOneOfCase;
@dynamic doubleValue;
@dynamic stringValue;

typedef struct EntryValue__storage_ {
  uint32_t _has_storage_[2];
  NSString *stringValue;
  double doubleValue;
} EntryValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "doubleValue",
        .dataTypeSpecific.className = NULL,
        .number = EntryValue_FieldNumber_DoubleValue,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(EntryValue__storage_, doubleValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "stringValue",
        .dataTypeSpecific.className = NULL,
        .number = EntryValue_FieldNumber_StringValue,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(EntryValue__storage_, stringValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EntryValue class]
                                     rootClass:[TestLogRoot class]
                                          file:TestLogRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EntryValue__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "kind",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void EntryValue_ClearKindOneOfCase(EntryValue *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - BenchmarkEntry

@implementation BenchmarkEntry

@dynamic name;
@dynamic iters;
@dynamic cpuTime;
@dynamic wallTime;
@dynamic throughput;
@dynamic extras, extras_Count;

typedef struct BenchmarkEntry__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSMutableDictionary *extras;
  int64_t iters;
  double cpuTime;
  double wallTime;
  double throughput;
} BenchmarkEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = BenchmarkEntry_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BenchmarkEntry__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iters",
        .dataTypeSpecific.className = NULL,
        .number = BenchmarkEntry_FieldNumber_Iters,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BenchmarkEntry__storage_, iters),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "cpuTime",
        .dataTypeSpecific.className = NULL,
        .number = BenchmarkEntry_FieldNumber_CpuTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BenchmarkEntry__storage_, cpuTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "wallTime",
        .dataTypeSpecific.className = NULL,
        .number = BenchmarkEntry_FieldNumber_WallTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BenchmarkEntry__storage_, wallTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "throughput",
        .dataTypeSpecific.className = NULL,
        .number = BenchmarkEntry_FieldNumber_Throughput,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BenchmarkEntry__storage_, throughput),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "extras",
        .dataTypeSpecific.className = GPBStringifySymbol(EntryValue),
        .number = BenchmarkEntry_FieldNumber_Extras,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BenchmarkEntry__storage_, extras),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BenchmarkEntry class]
                                     rootClass:[TestLogRoot class]
                                          file:TestLogRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BenchmarkEntry__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BenchmarkEntries

@implementation BenchmarkEntries

@dynamic entryArray, entryArray_Count;

typedef struct BenchmarkEntries__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *entryArray;
} BenchmarkEntries__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "entryArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BenchmarkEntry),
        .number = BenchmarkEntries_FieldNumber_EntryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BenchmarkEntries__storage_, entryArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BenchmarkEntries class]
                                     rootClass:[TestLogRoot class]
                                          file:TestLogRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BenchmarkEntries__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BuildConfiguration

@implementation BuildConfiguration

@dynamic mode;
@dynamic ccFlagsArray, ccFlagsArray_Count;
@dynamic optsArray, optsArray_Count;

typedef struct BuildConfiguration__storage_ {
  uint32_t _has_storage_[1];
  NSString *mode;
  NSMutableArray *ccFlagsArray;
  NSMutableArray *optsArray;
} BuildConfiguration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mode",
        .dataTypeSpecific.className = NULL,
        .number = BuildConfiguration_FieldNumber_Mode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BuildConfiguration__storage_, mode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ccFlagsArray",
        .dataTypeSpecific.className = NULL,
        .number = BuildConfiguration_FieldNumber_CcFlagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BuildConfiguration__storage_, ccFlagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "optsArray",
        .dataTypeSpecific.className = NULL,
        .number = BuildConfiguration_FieldNumber_OptsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BuildConfiguration__storage_, optsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BuildConfiguration class]
                                     rootClass:[TestLogRoot class]
                                          file:TestLogRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BuildConfiguration__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CommitId

@implementation CommitId

@dynamic kindOneOfCase;
@dynamic changelist;
@dynamic hash_p;
@dynamic snapshot;

typedef struct CommitId__storage_ {
  uint32_t _has_storage_[2];
  NSString *hash_p;
  NSString *snapshot;
  int64_t changelist;
} CommitId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "changelist",
        .dataTypeSpecific.className = NULL,
        .number = CommitId_FieldNumber_Changelist,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(CommitId__storage_, changelist),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = CommitId_FieldNumber_Hash_p,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(CommitId__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "snapshot",
        .dataTypeSpecific.className = NULL,
        .number = CommitId_FieldNumber_Snapshot,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CommitId__storage_, snapshot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CommitId class]
                                     rootClass:[TestLogRoot class]
                                          file:TestLogRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CommitId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "kind",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void CommitId_ClearKindOneOfCase(CommitId *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - CPUInfo

@implementation CPUInfo

@dynamic numCores;
@dynamic numCoresAllowed;
@dynamic mhzPerCpu;
@dynamic cpuInfo;
@dynamic cpuGovernor;
@dynamic cacheSize, cacheSize_Count;

typedef struct CPUInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *cpuInfo;
  NSString *cpuGovernor;
  GPBStringInt64Dictionary *cacheSize;
  int64_t numCores;
  int64_t numCoresAllowed;
  double mhzPerCpu;
} CPUInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "numCores",
        .dataTypeSpecific.className = NULL,
        .number = CPUInfo_FieldNumber_NumCores,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CPUInfo__storage_, numCores),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "numCoresAllowed",
        .dataTypeSpecific.className = NULL,
        .number = CPUInfo_FieldNumber_NumCoresAllowed,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CPUInfo__storage_, numCoresAllowed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "mhzPerCpu",
        .dataTypeSpecific.className = NULL,
        .number = CPUInfo_FieldNumber_MhzPerCpu,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CPUInfo__storage_, mhzPerCpu),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "cpuInfo",
        .dataTypeSpecific.className = NULL,
        .number = CPUInfo_FieldNumber_CpuInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CPUInfo__storage_, cpuInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cpuGovernor",
        .dataTypeSpecific.className = NULL,
        .number = CPUInfo_FieldNumber_CpuGovernor,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CPUInfo__storage_, cpuGovernor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cacheSize",
        .dataTypeSpecific.className = NULL,
        .number = CPUInfo_FieldNumber_CacheSize,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CPUInfo__storage_, cacheSize),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CPUInfo class]
                                     rootClass:[TestLogRoot class]
                                          file:TestLogRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CPUInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MemoryInfo

@implementation MemoryInfo

@dynamic total;
@dynamic available;

typedef struct MemoryInfo__storage_ {
  uint32_t _has_storage_[1];
  int64_t total;
  int64_t available;
} MemoryInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "total",
        .dataTypeSpecific.className = NULL,
        .number = MemoryInfo_FieldNumber_Total,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MemoryInfo__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "available",
        .dataTypeSpecific.className = NULL,
        .number = MemoryInfo_FieldNumber_Available,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MemoryInfo__storage_, available),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MemoryInfo class]
                                     rootClass:[TestLogRoot class]
                                          file:TestLogRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MemoryInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPUInfo

@implementation GPUInfo

@dynamic model;
@dynamic uuid;
@dynamic busId;

typedef struct GPUInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *model;
  NSString *uuid;
  NSString *busId;
} GPUInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "model",
        .dataTypeSpecific.className = NULL,
        .number = GPUInfo_FieldNumber_Model,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GPUInfo__storage_, model),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = GPUInfo_FieldNumber_Uuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GPUInfo__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "busId",
        .dataTypeSpecific.className = NULL,
        .number = GPUInfo_FieldNumber_BusId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GPUInfo__storage_, busId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPUInfo class]
                                     rootClass:[TestLogRoot class]
                                          file:TestLogRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPUInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PlatformInfo

@implementation PlatformInfo

@dynamic bits;
@dynamic linkage;
@dynamic machine;
@dynamic release_p;
@dynamic system;
@dynamic version;

typedef struct PlatformInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *bits;
  NSString *linkage;
  NSString *machine;
  NSString *release_p;
  NSString *system;
  NSString *version;
} PlatformInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bits",
        .dataTypeSpecific.className = NULL,
        .number = PlatformInfo_FieldNumber_Bits,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PlatformInfo__storage_, bits),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "linkage",
        .dataTypeSpecific.className = NULL,
        .number = PlatformInfo_FieldNumber_Linkage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PlatformInfo__storage_, linkage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "machine",
        .dataTypeSpecific.className = NULL,
        .number = PlatformInfo_FieldNumber_Machine,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PlatformInfo__storage_, machine),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "release_p",
        .dataTypeSpecific.className = NULL,
        .number = PlatformInfo_FieldNumber_Release_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PlatformInfo__storage_, release_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "system",
        .dataTypeSpecific.className = NULL,
        .number = PlatformInfo_FieldNumber_System,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PlatformInfo__storage_, system),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = PlatformInfo_FieldNumber_Version,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PlatformInfo__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PlatformInfo class]
                                     rootClass:[TestLogRoot class]
                                          file:TestLogRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PlatformInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AvailableDeviceInfo

@implementation AvailableDeviceInfo

@dynamic name;
@dynamic type;
@dynamic memoryLimit;
@dynamic physicalDescription;

typedef struct AvailableDeviceInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *type;
  NSString *physicalDescription;
  int64_t memoryLimit;
} AvailableDeviceInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = AvailableDeviceInfo_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AvailableDeviceInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = AvailableDeviceInfo_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AvailableDeviceInfo__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memoryLimit",
        .dataTypeSpecific.className = NULL,
        .number = AvailableDeviceInfo_FieldNumber_MemoryLimit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AvailableDeviceInfo__storage_, memoryLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "physicalDescription",
        .dataTypeSpecific.className = NULL,
        .number = AvailableDeviceInfo_FieldNumber_PhysicalDescription,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AvailableDeviceInfo__storage_, physicalDescription),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AvailableDeviceInfo class]
                                     rootClass:[TestLogRoot class]
                                          file:TestLogRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AvailableDeviceInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MachineConfiguration

@implementation MachineConfiguration

@dynamic hostname;
@dynamic serialIdentifier;
@dynamic hasPlatformInfo, platformInfo;
@dynamic hasCpuInfo, cpuInfo;
@dynamic deviceInfoArray, deviceInfoArray_Count;
@dynamic availableDeviceInfoArray, availableDeviceInfoArray_Count;
@dynamic hasMemoryInfo, memoryInfo;

typedef struct MachineConfiguration__storage_ {
  uint32_t _has_storage_[1];
  NSString *hostname;
  PlatformInfo *platformInfo;
  CPUInfo *cpuInfo;
  NSMutableArray *deviceInfoArray;
  NSMutableArray *availableDeviceInfoArray;
  MemoryInfo *memoryInfo;
  NSString *serialIdentifier;
} MachineConfiguration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hostname",
        .dataTypeSpecific.className = NULL,
        .number = MachineConfiguration_FieldNumber_Hostname,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MachineConfiguration__storage_, hostname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "platformInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PlatformInfo),
        .number = MachineConfiguration_FieldNumber_PlatformInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MachineConfiguration__storage_, platformInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cpuInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(CPUInfo),
        .number = MachineConfiguration_FieldNumber_CpuInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MachineConfiguration__storage_, cpuInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deviceInfoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = MachineConfiguration_FieldNumber_DeviceInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MachineConfiguration__storage_, deviceInfoArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "availableDeviceInfoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AvailableDeviceInfo),
        .number = MachineConfiguration_FieldNumber_AvailableDeviceInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MachineConfiguration__storage_, availableDeviceInfoArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "memoryInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(MemoryInfo),
        .number = MachineConfiguration_FieldNumber_MemoryInfo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MachineConfiguration__storage_, memoryInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "serialIdentifier",
        .dataTypeSpecific.className = NULL,
        .number = MachineConfiguration_FieldNumber_SerialIdentifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MachineConfiguration__storage_, serialIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MachineConfiguration class]
                                     rootClass:[TestLogRoot class]
                                          file:TestLogRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MachineConfiguration__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RunConfiguration

@implementation RunConfiguration

@dynamic argumentArray, argumentArray_Count;

typedef struct RunConfiguration__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *argumentArray;
} RunConfiguration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "argumentArray",
        .dataTypeSpecific.className = NULL,
        .number = RunConfiguration_FieldNumber_ArgumentArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RunConfiguration__storage_, argumentArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RunConfiguration class]
                                     rootClass:[TestLogRoot class]
                                          file:TestLogRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RunConfiguration__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TestResults

@implementation TestResults

@dynamic target;
@dynamic hasEntries, entries;
@dynamic hasBuildConfiguration, buildConfiguration;
@dynamic hasCommitId, commitId;
@dynamic startTime;
@dynamic runTime;
@dynamic hasMachineConfiguration, machineConfiguration;
@dynamic hasRunConfiguration, runConfiguration;
@dynamic name;
@dynamic benchmarkType;
@dynamic runMode;

typedef struct TestResults__storage_ {
  uint32_t _has_storage_[1];
  TestResults_BenchmarkType benchmarkType;
  NSString *target;
  BenchmarkEntries *entries;
  BuildConfiguration *buildConfiguration;
  CommitId *commitId;
  MachineConfiguration *machineConfiguration;
  RunConfiguration *runConfiguration;
  NSString *name;
  NSString *runMode;
  int64_t startTime;
  double runTime;
} TestResults__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "target",
        .dataTypeSpecific.className = NULL,
        .number = TestResults_FieldNumber_Target,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TestResults__storage_, target),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "entries",
        .dataTypeSpecific.className = GPBStringifySymbol(BenchmarkEntries),
        .number = TestResults_FieldNumber_Entries,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TestResults__storage_, entries),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "buildConfiguration",
        .dataTypeSpecific.className = GPBStringifySymbol(BuildConfiguration),
        .number = TestResults_FieldNumber_BuildConfiguration,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TestResults__storage_, buildConfiguration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "commitId",
        .dataTypeSpecific.className = GPBStringifySymbol(CommitId),
        .number = TestResults_FieldNumber_CommitId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TestResults__storage_, commitId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = TestResults_FieldNumber_StartTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TestResults__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "runTime",
        .dataTypeSpecific.className = NULL,
        .number = TestResults_FieldNumber_RunTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TestResults__storage_, runTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "machineConfiguration",
        .dataTypeSpecific.className = GPBStringifySymbol(MachineConfiguration),
        .number = TestResults_FieldNumber_MachineConfiguration,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(TestResults__storage_, machineConfiguration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "runConfiguration",
        .dataTypeSpecific.className = GPBStringifySymbol(RunConfiguration),
        .number = TestResults_FieldNumber_RunConfiguration,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(TestResults__storage_, runConfiguration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = TestResults_FieldNumber_Name,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(TestResults__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "benchmarkType",
        .dataTypeSpecific.enumDescFunc = TestResults_BenchmarkType_EnumDescriptor,
        .number = TestResults_FieldNumber_BenchmarkType,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(TestResults__storage_, benchmarkType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "runMode",
        .dataTypeSpecific.className = NULL,
        .number = TestResults_FieldNumber_RunMode,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(TestResults__storage_, runMode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TestResults class]
                                     rootClass:[TestLogRoot class]
                                          file:TestLogRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TestResults__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TestResults_BenchmarkType_RawValue(TestResults *message) {
  GPBDescriptor *descriptor = [TestResults descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TestResults_FieldNumber_BenchmarkType];
  return GPBGetMessageInt32Field(message, field);
}

void SetTestResults_BenchmarkType_RawValue(TestResults *message, int32_t value) {
  GPBDescriptor *descriptor = [TestResults descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TestResults_FieldNumber_BenchmarkType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum TestResults_BenchmarkType

GPBEnumDescriptor *TestResults_BenchmarkType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000CppMicrobenchmark\000PythonBenchmar"
        "k\000AndroidBenchmark\000";
    static const int32_t values[] = {
        TestResults_BenchmarkType_Unknown,
        TestResults_BenchmarkType_CppMicrobenchmark,
        TestResults_BenchmarkType_PythonBenchmark,
        TestResults_BenchmarkType_AndroidBenchmark,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TestResults_BenchmarkType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TestResults_BenchmarkType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TestResults_BenchmarkType_IsValidValue(int32_t value__) {
  switch (value__) {
    case TestResults_BenchmarkType_Unknown:
    case TestResults_BenchmarkType_CppMicrobenchmark:
    case TestResults_BenchmarkType_PythonBenchmark:
    case TestResults_BenchmarkType_AndroidBenchmark:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
