// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/util/test_log.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers.h>
#else
 #import "GPBProtocolBuffers.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30002
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30002 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

CF_EXTERN_C_BEGIN

@class AvailableDeviceInfo;
@class BenchmarkEntries;
@class BenchmarkEntry;
@class BuildConfiguration;
@class CPUInfo;
@class CommitId;
@class EntryValue;
@class GPBAny;
@class MachineConfiguration;
@class MemoryInfo;
@class PlatformInfo;
@class RunConfiguration;

NS_ASSUME_NONNULL_BEGIN

#pragma mark - Enum TestResults_BenchmarkType

/** The type of benchmark. */
typedef GPB_ENUM(TestResults_BenchmarkType) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  TestResults_BenchmarkType_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Fallback for protos written before Type was introduced. */
  TestResults_BenchmarkType_Unknown = 0,
  TestResults_BenchmarkType_CppMicrobenchmark = 1,
  TestResults_BenchmarkType_PythonBenchmark = 2,
  TestResults_BenchmarkType_AndroidBenchmark = 3,
};

GPBEnumDescriptor *TestResults_BenchmarkType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL TestResults_BenchmarkType_IsValidValue(int32_t value);

#pragma mark - TestLogRoot

/**
 * Exposes the extension registry for this file.
 *
 * The base class provides:
 * @code
 *   + (GPBExtensionRegistry *)extensionRegistry;
 * @endcode
 * which is a @c GPBExtensionRegistry that includes all the extensions defined by
 * this file and all files that it depends on.
 **/
@interface TestLogRoot : GPBRootObject
@end

#pragma mark - EntryValue

typedef GPB_ENUM(EntryValue_FieldNumber) {
  EntryValue_FieldNumber_DoubleValue = 1,
  EntryValue_FieldNumber_StringValue = 2,
};

typedef GPB_ENUM(EntryValue_Kind_OneOfCase) {
  EntryValue_Kind_OneOfCase_GPBUnsetOneOfCase = 0,
  EntryValue_Kind_OneOfCase_DoubleValue = 1,
  EntryValue_Kind_OneOfCase_StringValue = 2,
};

@interface EntryValue : GPBMessage

@property(nonatomic, readonly) EntryValue_Kind_OneOfCase kindOneOfCase;

@property(nonatomic, readwrite) double doubleValue;

@property(nonatomic, readwrite, copy, null_resettable) NSString *stringValue;

@end

/**
 * Clears whatever value was set for the oneof 'kind'.
 **/
void EntryValue_ClearKindOneOfCase(EntryValue *message);

#pragma mark - BenchmarkEntry

typedef GPB_ENUM(BenchmarkEntry_FieldNumber) {
  BenchmarkEntry_FieldNumber_Name = 1,
  BenchmarkEntry_FieldNumber_Iters = 2,
  BenchmarkEntry_FieldNumber_CpuTime = 3,
  BenchmarkEntry_FieldNumber_WallTime = 4,
  BenchmarkEntry_FieldNumber_Throughput = 5,
  BenchmarkEntry_FieldNumber_Extras = 6,
};

/**
 * Each unit test or benchmark in a test or benchmark run provides
 * some set of information.  Here we provide some reasonable keys
 * one would expect to see, with optional key/value pairs for things
 * we haven't considered.
 *
 * This BenchmarkEntry should be emitted by each unit test or benchmark
 * reporter.
 **/
@interface BenchmarkEntry : GPBMessage

/**
 * The name of the specific benchmark or test
 * (e.g. BM_AdjustContrast_gpu_B_W_H)
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *name;

/** If a benchmark, how many iterations it was run for */
@property(nonatomic, readwrite) int64_t iters;

/** Total cpu time used for all iterations (in seconds) */
@property(nonatomic, readwrite) double cpuTime;

/** Total wall time used for all iterations (in seconds) */
@property(nonatomic, readwrite) double wallTime;

/** Throughput (in MB/s) */
@property(nonatomic, readwrite) double throughput;

/** Generic map from result key to value. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableDictionary<NSString*, EntryValue*> *extras;
/** The number of items in @c extras without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger extras_Count;

@end

#pragma mark - BenchmarkEntries

typedef GPB_ENUM(BenchmarkEntries_FieldNumber) {
  BenchmarkEntries_FieldNumber_EntryArray = 1,
};

@interface BenchmarkEntries : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<BenchmarkEntry*> *entryArray;
/** The number of items in @c entryArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger entryArray_Count;

@end

#pragma mark - BuildConfiguration

typedef GPB_ENUM(BuildConfiguration_FieldNumber) {
  BuildConfiguration_FieldNumber_Mode = 1,
  BuildConfiguration_FieldNumber_CcFlagsArray = 2,
  BuildConfiguration_FieldNumber_OptsArray = 3,
};

@interface BuildConfiguration : GPBMessage

/** opt, dbg, etc */
@property(nonatomic, readwrite, copy, null_resettable) NSString *mode;

/** CC compiler flags, if known */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NSString*> *ccFlagsArray;
/** The number of items in @c ccFlagsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger ccFlagsArray_Count;

/** Bazel compilation options, if known */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NSString*> *optsArray;
/** The number of items in @c optsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger optsArray_Count;

@end

#pragma mark - CommitId

typedef GPB_ENUM(CommitId_FieldNumber) {
  CommitId_FieldNumber_Changelist = 1,
  CommitId_FieldNumber_Hash_p = 2,
  CommitId_FieldNumber_Snapshot = 3,
};

typedef GPB_ENUM(CommitId_Kind_OneOfCase) {
  CommitId_Kind_OneOfCase_GPBUnsetOneOfCase = 0,
  CommitId_Kind_OneOfCase_Changelist = 1,
  CommitId_Kind_OneOfCase_Hash_p = 2,
};

@interface CommitId : GPBMessage

@property(nonatomic, readonly) CommitId_Kind_OneOfCase kindOneOfCase;

@property(nonatomic, readwrite) int64_t changelist;

@property(nonatomic, readwrite, copy, null_resettable) NSString *hash_p;

/**
 * Hash of intermediate change between hash/changelist and what was tested.
 * Not used if the build is from a commit without modifications.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *snapshot;

@end

/**
 * Clears whatever value was set for the oneof 'kind'.
 **/
void CommitId_ClearKindOneOfCase(CommitId *message);

#pragma mark - CPUInfo

typedef GPB_ENUM(CPUInfo_FieldNumber) {
  CPUInfo_FieldNumber_NumCores = 1,
  CPUInfo_FieldNumber_NumCoresAllowed = 2,
  CPUInfo_FieldNumber_MhzPerCpu = 3,
  CPUInfo_FieldNumber_CpuInfo = 4,
  CPUInfo_FieldNumber_CpuGovernor = 5,
  CPUInfo_FieldNumber_CacheSize = 6,
};

@interface CPUInfo : GPBMessage

@property(nonatomic, readwrite) int64_t numCores;

@property(nonatomic, readwrite) int64_t numCoresAllowed;

/** How fast are these cpus? */
@property(nonatomic, readwrite) double mhzPerCpu;

/**
 * Additional cpu information. For example,
 * Intel Ivybridge with HyperThreading (24 cores) dL1:32KB dL2:256KB dL3:30MB
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *cpuInfo;

/**
 * What kind of cpu scaling is enabled on the host.
 * Examples include "performance", "ondemand", "conservative", "mixed".
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *cpuGovernor;

/** Cache sizes (in bytes), e.g. "L2": 262144 (for 256KB) */
@property(nonatomic, readwrite, strong, null_resettable) GPBStringInt64Dictionary *cacheSize;
/** The number of items in @c cacheSize without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger cacheSize_Count;

@end

#pragma mark - MemoryInfo

typedef GPB_ENUM(MemoryInfo_FieldNumber) {
  MemoryInfo_FieldNumber_Total = 1,
  MemoryInfo_FieldNumber_Available = 2,
};

@interface MemoryInfo : GPBMessage

/** Total virtual memory in bytes */
@property(nonatomic, readwrite) int64_t total;

/** Immediately available memory in bytes */
@property(nonatomic, readwrite) int64_t available;

@end

#pragma mark - GPUInfo

typedef GPB_ENUM(GPUInfo_FieldNumber) {
  GPUInfo_FieldNumber_Model = 1,
  GPUInfo_FieldNumber_Uuid = 2,
  GPUInfo_FieldNumber_BusId = 3,
};

@interface GPUInfo : GPBMessage

/** e.g. "Tesla K40c" */
@property(nonatomic, readwrite, copy, null_resettable) NSString *model;

/** Final entry in output of "nvidia-smi -L" */
@property(nonatomic, readwrite, copy, null_resettable) NSString *uuid;

/** e.g. "0000:04:00.0" */
@property(nonatomic, readwrite, copy, null_resettable) NSString *busId;

@end

#pragma mark - PlatformInfo

typedef GPB_ENUM(PlatformInfo_FieldNumber) {
  PlatformInfo_FieldNumber_Bits = 1,
  PlatformInfo_FieldNumber_Linkage = 2,
  PlatformInfo_FieldNumber_Machine = 3,
  PlatformInfo_FieldNumber_Release_p = 4,
  PlatformInfo_FieldNumber_System = 5,
  PlatformInfo_FieldNumber_Version = 6,
};

@interface PlatformInfo : GPBMessage

/** e.g. '64bit' */
@property(nonatomic, readwrite, copy, null_resettable) NSString *bits;

/** e.g. 'ELF' */
@property(nonatomic, readwrite, copy, null_resettable) NSString *linkage;

/** e.g. 'i386' */
@property(nonatomic, readwrite, copy, null_resettable) NSString *machine;

/** e.g. '3.13.0-76-generic' */
@property(nonatomic, readwrite, copy, null_resettable) NSString *release_p;

/** e.g. 'Linux' */
@property(nonatomic, readwrite, copy, null_resettable) NSString *system;

/** e.g. '#120-Ubuntu SMP Mon Jan 18 15:59:10 UTC 2016' */
@property(nonatomic, readwrite, copy, null_resettable) NSString *version;

@end

#pragma mark - AvailableDeviceInfo

typedef GPB_ENUM(AvailableDeviceInfo_FieldNumber) {
  AvailableDeviceInfo_FieldNumber_Name = 1,
  AvailableDeviceInfo_FieldNumber_Type = 2,
  AvailableDeviceInfo_FieldNumber_MemoryLimit = 3,
  AvailableDeviceInfo_FieldNumber_PhysicalDescription = 4,
};

/**
 * Matches DeviceAttributes
 **/
@interface AvailableDeviceInfo : GPBMessage

/** Device name. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *name;

/** Device type, e.g. 'CPU' or 'GPU'. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *type;

/** Memory capacity in bytes. */
@property(nonatomic, readwrite) int64_t memoryLimit;

/** The physical description of this device. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *physicalDescription;

@end

#pragma mark - MachineConfiguration

typedef GPB_ENUM(MachineConfiguration_FieldNumber) {
  MachineConfiguration_FieldNumber_Hostname = 1,
  MachineConfiguration_FieldNumber_PlatformInfo = 2,
  MachineConfiguration_FieldNumber_CpuInfo = 3,
  MachineConfiguration_FieldNumber_DeviceInfoArray = 4,
  MachineConfiguration_FieldNumber_AvailableDeviceInfoArray = 5,
  MachineConfiguration_FieldNumber_MemoryInfo = 6,
  MachineConfiguration_FieldNumber_SerialIdentifier = 7,
};

@interface MachineConfiguration : GPBMessage

/** Host name of machine that ran the benchmark. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *hostname;

/** Unique serial number of the machine. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *serialIdentifier;

/** Additional platform information. */
@property(nonatomic, readwrite, strong, null_resettable) PlatformInfo *platformInfo;
/** Test to see if @c platformInfo has been set. */
@property(nonatomic, readwrite) BOOL hasPlatformInfo;

/** CPU Information. */
@property(nonatomic, readwrite, strong, null_resettable) CPUInfo *cpuInfo;
/** Test to see if @c cpuInfo has been set. */
@property(nonatomic, readwrite) BOOL hasCpuInfo;

/** Other devices that are attached and relevant (e.g. GPUInfo). */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<GPBAny*> *deviceInfoArray;
/** The number of items in @c deviceInfoArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger deviceInfoArray_Count;

/** Devices accessible to the test (e.g. as given by list_local_devices). */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<AvailableDeviceInfo*> *availableDeviceInfoArray;
/** The number of items in @c availableDeviceInfoArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger availableDeviceInfoArray_Count;

@property(nonatomic, readwrite, strong, null_resettable) MemoryInfo *memoryInfo;
/** Test to see if @c memoryInfo has been set. */
@property(nonatomic, readwrite) BOOL hasMemoryInfo;

@end

#pragma mark - RunConfiguration

typedef GPB_ENUM(RunConfiguration_FieldNumber) {
  RunConfiguration_FieldNumber_ArgumentArray = 1,
};

/**
 * Run-specific items such as arguments to the test / benchmark.
 **/
@interface RunConfiguration : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NSString*> *argumentArray;
/** The number of items in @c argumentArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger argumentArray_Count;

@end

#pragma mark - TestResults

typedef GPB_ENUM(TestResults_FieldNumber) {
  TestResults_FieldNumber_Target = 1,
  TestResults_FieldNumber_Entries = 2,
  TestResults_FieldNumber_BuildConfiguration = 3,
  TestResults_FieldNumber_CommitId = 4,
  TestResults_FieldNumber_StartTime = 5,
  TestResults_FieldNumber_RunTime = 6,
  TestResults_FieldNumber_MachineConfiguration = 7,
  TestResults_FieldNumber_RunConfiguration = 8,
  TestResults_FieldNumber_Name = 9,
  TestResults_FieldNumber_BenchmarkType = 10,
  TestResults_FieldNumber_RunMode = 11,
};

/**
 * The output of one benchmark / test run.  Each run contains a list of
 * tests or benchmarks, stored as BenchmarkEntry messages.
 *
 * This message should be emitted by the reporter (which runs the
 * test / BM in a subprocess and then reads the emitted BenchmarkEntry messages;
 * usually from a serialized json file, finally collecting them along
 * with additional information about the test run.
 **/
@interface TestResults : GPBMessage

/**
 * The target of the run, e.g.:
 *  //tensorflow/core:kernels_adjust_contrast_op_benchmark_test
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *target;

/** The list of tests or benchmarks in this run. */
@property(nonatomic, readwrite, strong, null_resettable) BenchmarkEntries *entries;
/** Test to see if @c entries has been set. */
@property(nonatomic, readwrite) BOOL hasEntries;

/** The configuration of the build (compiled opt? with cuda? any copts?) */
@property(nonatomic, readwrite, strong, null_resettable) BuildConfiguration *buildConfiguration;
/** Test to see if @c buildConfiguration has been set. */
@property(nonatomic, readwrite) BOOL hasBuildConfiguration;

/** The commit id (git hash or changelist) */
@property(nonatomic, readwrite, strong, null_resettable) CommitId *commitId;
/** Test to see if @c commitId has been set. */
@property(nonatomic, readwrite) BOOL hasCommitId;

/** The time the run started (in seconds of UTC time since Unix epoch) */
@property(nonatomic, readwrite) int64_t startTime;

/** The amount of time the total run took (wall time in seconds) */
@property(nonatomic, readwrite) double runTime;

/** Machine-specific parameters (Platform and CPU info) */
@property(nonatomic, readwrite, strong, null_resettable) MachineConfiguration *machineConfiguration;
/** Test to see if @c machineConfiguration has been set. */
@property(nonatomic, readwrite) BOOL hasMachineConfiguration;

/** Run-specific parameters (arguments, etc) */
@property(nonatomic, readwrite, strong, null_resettable) RunConfiguration *runConfiguration;
/** Test to see if @c runConfiguration has been set. */
@property(nonatomic, readwrite) BOOL hasRunConfiguration;

/** Benchmark target identifier. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *name;

@property(nonatomic, readwrite) TestResults_BenchmarkType benchmarkType;

/** Used for differentiating between continuous and debug builds. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *runMode;

@end

/**
 * Fetches the raw value of a @c TestResults's @c benchmarkType property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t TestResults_BenchmarkType_RawValue(TestResults *message);
/**
 * Sets the raw value of an @c TestResults's @c benchmarkType property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetTestResults_BenchmarkType_RawValue(TestResults *message, int32_t value);

NS_ASSUME_NONNULL_END

CF_EXTERN_C_END

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
